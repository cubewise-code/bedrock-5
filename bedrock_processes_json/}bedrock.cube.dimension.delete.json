{
  "Name": "}bedrock.cube.dimension.delete",
  "PrologProcedure": "#Region CallThisProcess\r\n# A snippet of code provided as an example how to call this process should the developer be working on a system without access to an editor with auto-complete.\r\nIf( 1 = 0 );\r\n    ExecuteProcess( '}bedrock.cube.dimension.delete', 'pLogOutput', pLogOutput,\r\n      'pStrictErrorHandling', pStrictErrorHandling,\r\n    \t'pCube', '', 'pDim', '',\r\n    \t'pIncludeData', 1, 'pIncludeRules', 2,\r\n    \t'pCtrlObj', 0, 'pTemp', 1\r\n\t);\r\nEndIf;\r\n#EndRegion CallThisProcess\r\n\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n\r\n################################################################################################# \r\n##~~Join the bedrock TM1 community on GitHub https://github.com/cubewise-code/bedrock-5 Ver 5.0~~##\r\n################################################################################################# \r\n\r\n#Region @DOC\r\n# Description:\r\n# This TI deletes a dimension from a cube that has already been built with the ability to preserve data.\r\n\r\n# Use case: Intended for development/prototyping.\r\n# 1/ Rebuild existing cube with the removal of one dimension without losing all the data.\r\n\r\n# Note:\r\n# Naturally, a valid cube name (pCube) is mandatory otherwise the process will abort.\r\n# Also, a valid dimension name (pDim) is mandatory otherwise the process will abort.\r\n# If data needs to be kept (using pIncludeData), data from pDim will be summed.\r\n# Rule can be kept as backup file only or reloaded back.\r\n#EndRegion @DOC\r\n\r\n### Global Variables\r\nStringGlobalVariable('sProcessReturnCode');\r\nNumericGlobalVariable('nProcessReturnCode');\r\nnProcessReturnCode= 0;\r\n\r\n### Constants ###\r\ncThisProcName   = GetProcessName();\r\ncUserName       = TM1User();\r\ncTimeStamp      = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\r\ncRandomInt      = NumberToString( INT( RAND( ) * 1000 ));\r\ncTempSub        = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\r\ncMsgErrorLevel  = 'ERROR';\r\ncMsgErrorContent= 'Process:%cThisProcName% ErrorMsg:%sMessage%';\r\ncLogInfo        = 'Process:%cThisProcName% run with parameters pCube:%pCube%, pDim:%pDim%, pIncludeData:%pIncludeData%, pIncludeRules:%pIncludeRules%, pCtrlObj:%pCtrlObj%, pTemp:%pTemp%.';\r\n\r\n#################################################################################################\r\n#Region - Process Parameters\r\n\r\npJson = IF( JsonType( pJson ) @<> 'object', '{}', pJson );\r\nsMessages = '{\"Process\": \"'|GetProcessName()|'\", \"User\": \"'|TM1User()|'\", \"Info\": [\"Process: '''|GetProcessName()|''' run by User: '''|TM1User()|'''.\"], \"Error\": []}';\r\npDefaultParameters = '{\r\n  \"pCube\":                null,\r\n  \"pDim\":                 null,\r\n  \"pCtrlObj\":             0,\r\n  \"pIncludeData\":         0,\r\n  \"pIncludeRules\":        1,\r\n  \"pLogOutput\":           0,\r\n  \"pStrictErrorHandling\": 0,\r\n  \"pTemp\":                1\r\n}';\r\n\r\npPassedParameters = '{\r\n  \"pCube\":                '|StringToJson  ( pCube                )|',\r\n  \"pDim\":                 '|StringToJson  ( pDim                 )|',\r\n  \"pCtrlObj\":             '|NumberToString( pCtrlObj             )|',\r\n  \"pIncludeData\":         '|NumberToString( pIncludeData         )|',\r\n  \"pIncludeRules\":        '|NumberToString( pIncludeRules        )|',\r\n  \"pLogOutput\":           '|NumberToString( pLogOutput           )|',\r\n  \"pStrictErrorHandling\": '|NumberToString( pStrictErrorHandling )|',\r\n  \"pTemp\":                '|NumberToString( pTemp                )|'\r\n}';\r\n\r\npJson = JsonMergePatch( pPassedParameters, pJson );\r\n# String Parameters\r\npCube                =                 JsonToString( JsonGet( pJson, 'pCube'              ) );\r\npDim                 =                 JsonToString( JsonGet( pJson, 'pDim'               ) );\r\n# Numeric Parameters\r\npCtrlObj             = StringToNumber( JsonToString( JsonGet( pJson, 'pCtrlObj'           ) ) );\r\npIncludeData         = StringToNumber( JsonToString( JsonGet( pJson, 'pIncludeData'       ) ) );\r\npIncludeRules        = StringToNumber( JsonToString( JsonGet( pJson, 'pIncludeRules'      ) ) );\r\npLogOutput           = StringToNumber( JsonToString( JsonGet( pJson, 'pLogOutput'         ) ) );\r\npStrictErrorHandling = StringToNumber( JsonToString( JsonGet( pJson, 'pStrictErrorHandling' ) ) );\r\npTemp                = StringToNumber( JsonToString( JsonGet( pJson, 'pTemp'              ) ) );\r\n\r\n### Get the parameters that differ from the default\r\npDiffer = JsonDiff( pDefaultParameters, pJson );\r\nnSize = JsonSize( pDiffer );\r\nWHILE( nSize > 0 );\r\n  nSize = nSize - 1;\r\n  pDiffer = JsonReplace( pDiffer, '/'|NumberToString( nSize )|'/op', '\"add\"' );\r\nEND;\r\npJson = JsonPatch( '{}', pDiffer );\r\n\r\n### LogOutput parameters\r\nsMessages = JsonAdd( sMessages, '/Info/-', pJson );\r\nIF( pLogOutput = 1 );\r\n  LogOutput('INFO', JsonToString( sMessages, '/Info/0', 0, ' ' ) );\r\nENDIF;\r\n\r\n#EndRegion - Process Parameters\r\n#################################################################################################\r\n\r\n## check operating system\r\nIf( SubSt( GetProcessErrorFileDirectory, 2, 1 ) @= ':' );\r\n  sOS = 'Windows';\r\n  sOSDelim = '\\';\r\nElseIf( Scan( '/', GetProcessErrorFileDirectory ) > 0 );\r\n  sOS = 'Linux';\r\n  sOSDelim = '/';\r\nElse;\r\n  sOS = 'Windows';\r\n  sOSDelim = '\\';\r\nEndIf;\r\n\r\n## LogOutput parameters\r\nIF( pLogoutput = 1 );\r\n    LogOutput('INFO', Expand( cLogInfo ) );   \r\nENDIF;\r\n\r\n### Validate Parameters ###\r\nnErrors = 0;\r\n# Validate cube\r\nIf( Trim( pCube ) @= '' );\r\n    nErrors = nErrors + 1;\r\n    sMessage = 'No cube specified.';\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nElseIf( CubeExists( pCube ) = 0 );\r\n    nErrors = nErrors + 1;\r\n    sMessage = Expand( 'Invalid cube specified: %pCube%.');\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nEndIf;\r\n\r\n# Don't allow system cubes to be modified\r\nIf( SubSt( pCube, 1, 1 ) @= '}' & pCtrlObj <= 0 );\r\n    nErrors = nErrors + 1;\r\n    sMessage = Expand( 'Do not modify system cubes: %pCube%.');\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nEndIf;\r\n\r\n# Validate dimension\r\nIf( Trim( pDim ) @= '' );\r\n    nErrors = nErrors + 1;\r\n    sMessage = 'No dimension specified.';\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nElseIf( DimensionExists( pDim ) = 0 );\r\n    nErrors = nErrors + 1;\r\n    sMessage = Expand( 'New dimension: %pDim% does not exist');\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nEndIf;\r\n\r\nIF(pIncludeRules = 1 % pIncludeRules = 2);\r\n    cCubeRule=CubeRuleGet( pCube );\r\n    If(cCubeRule @= '');\r\n        pIncludeRules = 0;\r\n        LogOutput( 'INFO', Expand( 'No rule found for %pCube%.' ) );\r\n    Endif;\r\nEndif;  \r\n\r\n### Determine number of dims in source cube & create strings to check and recreate ###\r\nnCount = 1;\r\nsDimString = '';\r\nsDimCheck = '';\r\nsDelim = '+';\r\nnSkip=0;\r\nnIncrement = 1;\r\nWhile( TabDim( pCube, nCount ) @<> '' );\r\n    sDim = TabDim( pCube, nCount );\r\n    IF(sDim@=pDim);\r\n        nSkip = 1;\r\n    else;\r\n        nSkip = 0;\r\n    Endif; \r\n    sDimCheck = sDimCheck|'+'|sDim|'+';\r\n    IF(nSkip = 0);\r\n        sDimString = sDimString|'+'|sDim;\r\n    Endif;\r\n    nCount = nCount + 1;\r\nEnd;\r\nnDimensionCount = nCount-1;\r\n\r\n#Remove any leading +\r\nIF( Subst( sDimString , 1 , 1 ) @= '+' );\r\n    sDimString      = Subst ( sDimString , 2 , Long(sDimString)-1 );\r\nEndIf;\r\n\r\nIF( Scan('+'|Lower(pDim)|'+', Lower(sDimCheck)) = 0);\r\n    nErrors = nErrors + 1;\r\n    sMessage = Expand( 'The chosen dimension %pDim% does not exists in cube %pCube%.');\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nEndif;\r\n\r\n# Check if cube exceeds current max dimenions\r\nIf( nDimensionCount > 27 );\r\n    sMessage = 'Process needs to be modified to handle cubes with more than 27 dimensions';\r\n    nErrors = nErrors + 1;\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nEndIf;\r\n\r\n### Check for errors before continuing\r\nIf( nErrors <> 0 );\r\n  If( pStrictErrorHandling = 1 ); \r\n      ProcessQuit; \r\n  Else;\r\n      ProcessBreak;\r\n  EndIf;\r\nEndIf;\r\n\r\n######  CALLING THE STEP PROCESSES #####\r\n\r\n# Keep the rule\r\nIF(pIncludeRules = 1 % pIncludeRules = 2);\r\n  \r\n  sProc = '}bedrock.cube.rule.manage';\r\n\r\n  nRet = ExecuteProcess( sProc,\r\n    'pLogOutput', pLogOutput,\r\n    'pStrictErrorHandling', pStrictErrorHandling,\r\n    'pCube', pCube,\r\n    'pMode', 'UNLOAD'\r\n    );\r\n    \r\n  IF(nRet <> 0);\r\n    sMessage = 'Error unloading the rule for %pCube%.';\r\n    nErrors = nErrors + 1;\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n    If( pStrictErrorHandling = 1 ); \r\n        ProcessQuit; \r\n    Else;\r\n        ProcessBreak;\r\n    EndIf;\r\n  ENDIF;\r\n  \r\nEndif; \r\n\r\n# create clone cube with data\r\nIF(pIncludeData = 1);\r\n    pCloneCube = pCube | '_Clone';\r\n    nIncludeRules = IF(pIncludeRules = 1 % pIncludeRules = 2, 1, 0);\r\n    nSuppressRules = IF(nIncludeRules = 1,  1, 0);\r\n  \r\n    sProc = '}bedrock.cube.clone';\r\n    nRet = ExecuteProcess( sProc,\r\n        'pLogOutput', pLogOutput,\r\n        'pStrictErrorHandling', pStrictErrorHandling,\r\n        'pSrcCube', pCube,\r\n        'pTgtCube', pCloneCube,\r\n        'pIncludeRules', nIncludeRules,\r\n        'pIncludeData', pIncludeData,\r\n        'pSuppressRules', nSuppressRules,\r\n        'pTemp', pTemp,\r\n        'pCubeLogging', 0\r\n        );\r\n\r\n    IF(nRet <> 0);\r\n        sMessage = 'Error creating cloned cube for keeping data.';\r\n        nErrors = nErrors + 1;\r\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n        If( pStrictErrorHandling = 1 ); \r\n            ProcessQuit; \r\n        Else;\r\n            ProcessBreak;\r\n        EndIf;\r\n    ENDIF;\r\n  \r\nEndif;\r\n\r\n#Processbreak;\r\n\r\n# recreate the cube\r\nsProc = '}bedrock.cube.create';\r\nnRet = ExecuteProcess( sProc,\r\n    'pLogOutput', pLogOutput,\r\n    'pStrictErrorHandling', pStrictErrorHandling,\r\n    'pCube', pCube,\r\n    'pDims', sDimString,\r\n    'pRecreate', 1,\r\n    'pDelim', sDelim\r\n    );\r\n\r\nIF(nRet <> 0);\r\n    sMessage = Expand('Error recreating the cube: %pCube%.');\r\n    nErrors = nErrors + 1;\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n    If( pStrictErrorHandling = 1 ); \r\n        ProcessQuit; \r\n    Else;\r\n        ProcessBreak;\r\n    EndIf;\r\nENDIF;\r\n\r\n#Processbreak;\r\n\r\n# copy back the data\r\nIF(pIncludeData = 1);\r\n    sProc = '}bedrock.cube.data.copy.intercube';\r\n    nRet = ExecuteProcess( sProc,\r\n        'pLogOutput', pLogOutput,\r\n        'pStrictErrorHandling', pStrictErrorHandling,\r\n        'pSrcCube', pCloneCube,\r\n        'pFilter', '',\r\n        'pTgtCube', pCube,\r\n        'pMappingToNewDims', '',\r\n        'pSuppressConsol', 1,\r\n        'pSuppressRules', nSuppressRules,\r\n        'pZeroSource', 0,\r\n        'pZeroTarget', 0,\r\n        'pFactor', 1,\r\n        'pTemp', pTemp,\r\n        'pCubeLogging', 0\r\n        );  \r\n    \r\n    IF(nRet <> 0);\r\n        sMessage = Expand('Error copying back the data from clone cube: %pCloneCube%.');\r\n        nErrors = nErrors + 1;\r\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n        If( pStrictErrorHandling = 1 ); \r\n            ProcessQuit; \r\n        Else;\r\n            ProcessBreak;\r\n        EndIf;\r\n    ENDIF;\r\n  \r\n    # destroy clone cube\r\n    IF(pTemp=1);\r\n        sProc = '}bedrock.cube.delete';\r\n        nRet = ExecuteProcess( sProc,\r\n        'pLogOutput', pLogOutput,\r\n        'pStrictErrorHandling', pStrictErrorHandling,\r\n        'pCube', pCloneCube,\r\n        'pCtrlObj', 0\r\n        );\r\n\r\n        IF(nRet <> 0);\r\n            sMessage = Expand('Error deleting cloned cube: %pCloneCube%.');\r\n            nErrors = nErrors + 1;\r\n            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n            If( pStrictErrorHandling = 1 ); \r\n                ProcessQuit; \r\n            Else;\r\n                ProcessBreak;\r\n            EndIf;\r\n        ENDIF;\r\n    Endif;\r\n  \r\nEndif; \r\n\r\n# reload the rule\r\nIF(pIncludeRules = 2);\r\n  \r\n  sProc = '}bedrock.cube.rule.manage';\r\n\r\n  nRet = ExecuteProcess( sProc,\r\n    'pLogOutput', pLogOutput,\r\n    'pStrictErrorHandling', pStrictErrorHandling,\r\n    'pCube', pCube,\r\n    'pMode', 'LOAD'\r\n    );\r\n    \r\n  IF(nRet <> 0);\r\n    sMessage = Expand('Error reloading the rule for %pCube%.');\r\n    nErrors = nErrors + 1;\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n    # Create error rule file \r\n    cErrorRuleName = 'ErrorRuleFile.rux';\r\n\r\n    IF(FileExists( Lower(cErrorRuleName) ) = 0 );\r\n      sFile = '.' | sOSDelim | Lower(cErrorRuleName);\r\n      LogOutput(cMsgErrorLevel, 'Rule could not be attached due to invalid !Dimension references. Please recover from the backup and fix manually.');\r\n    ENDIF;\r\n\r\n    ExecuteProcess( sProc,\r\n    'pLogOutput', pLogOutput,\r\n    'pStrictErrorHandling', pStrictErrorHandling,\r\n    'pCube', pCube,\r\n    'pFileName', Lower(cErrorRuleName),\r\n    'pMode', 'LOAD'\r\n    );\r\n    If( pStrictErrorHandling = 1 ); \r\n        ProcessQuit; \r\n    Else;\r\n        ProcessBreak;\r\n    EndIf;\r\n  ENDIF;\r\n  \r\nEndif; \r\n\r\n### End Prolog ###",
  "MetadataProcedure": "\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n",
  "DataProcedure": "\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n",
  "EpilogProcedure": "\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n\r\n################################################################################################# \r\n##~~Join the bedrock TM1 community on GitHub https://github.com/cubewise-code/bedrock-5 Ver 5.0~~##\r\n################################################################################################# \r\n\r\n### Return code & final error message handling\r\nIf( nErrors > 0 );\r\n    sMessage = 'the process incurred at least 1 error. Please see above lines in this file for more details.';\r\n    nProcessReturnCode = 0;\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\r\n    If( pStrictErrorHandling = 1 ); \r\n        ProcessQuit; \r\n    EndIf;\r\nElse;\r\n    sProcessAction = Expand( 'Process:%cThisProcName% successfully deleted dimension %pDim% from the %pCube% cube.' );\r\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\r\n    nProcessReturnCode = 1;\r\n    If( pLogoutput = 1 );\r\n        LogOutput('INFO', Expand( sProcessAction ) );   \r\n    EndIf;\r\nEndIf;\r\n\r\n### End Epilog ###",
  "HasSecurityAccess": true,
  "UIData": "",
  "DataSource": {
    "Type": "None"
  },
  "Parameters": [
    {
      "Name": "pCube",
      "Prompt": "REQUIRED: Cube name",
      "Value": "",
      "Type": "String"
    },
    {
      "Name": "pDim",
      "Prompt": "REQUIRED: Dimension to be deleted",
      "Value": "",
      "Type": "String"
    },
    {
      "Name": "pIncludeData",
      "Prompt": "OPTIONAL: Include cube data (Boolean. Default = 0)",
      "Value": 0,
      "Type": "Numeric"
    },
    {
      "Name": "pIncludeRules",
      "Prompt": "OPTIONAL: Include cube rules (Boolean. Default = 1)",
      "Value": 1,
      "Type": "Numeric"
    },
    {
      "Name": "pCtrlObj",
      "Prompt": "OPTIONAL: OPTIONAL: Allow modification of control objects (Boolean. Default = 0)",
      "Value": 0,
      "Type": "Numeric"
    },
    {
      "Name": "pTemp",
      "Prompt": "OPTIONAL: Delete/create temporary objects (0 = Do not delete, 1 = Delete, 2 = if view and subsets are created, keep only subsets)",
      "Value": 1,
      "Type": "Numeric"
    },
    {
      "Name": "pLogOutput",
      "Prompt": "OPTIONAL: Write parameters and action summary to server message log (Boolean. Default = 0)",
      "Value": 0,
      "Type": "Numeric"
    },
    {
      "Name": "pStrictErrorHandling",
      "Prompt": "OPTIONAL: On encountering any error, exit with major error status by ProcessQuit after writing to the server message log (Boolean. Default = 0)",
      "Value": 0,
      "Type": "Numeric"
    },
    {
      "Name": "pJson",
      "Prompt": "OPTIONAL: JSON Object with process parameter values. This will overwrite user passed parameters for all included parameters.",
      "Value": "{}",
      "Type": "String"
    }
  ],
  "Variables": [],
  "VariablesUIData": []
}