{
  "Name": "}bedrock.cube.dimension.add",
  "PrologProcedure": "#Region CallThisProcess\r\n# A snippet of code provided as an example how to call this process should the developer be working on a system without access to an editor with auto-complete.\r\nIf( 1 = 0 );\r\n    ExecuteProcess( '}bedrock.cube.dimension.add', 'pLogOutput', pLogOutput,\r\n      'pStrictErrorHandling', pStrictErrorHandling,\r\n    \t'pCube', '', 'pDim', '', 'pDimIndex', 1,\r\n    \t'pIncludeData', 0, 'pEle', '', 'pIncludeRules', 2,\r\n    \t'pCtrlObj', 0, 'pTemp', 1\r\n\t);\r\nEndIf;\r\n#EndRegion CallThisProcess\r\n\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n\r\n################################################################################################# \r\n##~~Join the bedrock TM1 community on GitHub https://github.com/cubewise-code/bedrock Ver 4.0~~##\r\n################################################################################################# \r\n\r\n#Region @DOC\r\n# Description:\r\n# This TI adds a dimension to a cube that has already been built with the ability to preserve data.\r\n\r\n# Use case: Intended for development/prototyping.\r\n# 1/ Rebuild existing cube with extra dimension without losing data.\r\n\r\n# Note:\r\n# Naturally, a valid target cube name (pCube) is mandatory otherwise the process will abort.\r\n# Also, a valid new dimension name (pDim) is mandatory otherwise the process will abort.\r\n# When data needs to be kept (using pIncludeData) a valid element (pEle) must be specified where to store the data in new dimension.\r\n# Rule can be kept as backup file only or reloaded back.\r\n#EndRegion @DOC\r\n\r\n### Global Variables\r\nStringGlobalVariable('sProcessReturnCode');\r\nNumericGlobalVariable('nProcessReturnCode');\r\nnProcessReturnCode= 0;\r\n\r\n### Constants ###\r\ncThisProcName   = GetProcessName();\r\ncUserName       = TM1User();\r\ncTimeStamp      = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\r\ncRandomInt      = NumberToString( INT( RAND( ) * 1000 ));\r\ncTempSub        = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\r\ncMsgErrorLevel  = 'ERROR';\r\ncMsgErrorContent= 'Process:%cThisProcName% ErrorMsg:%sMessage%';\r\ncLogInfo        = 'Process:%cThisProcName% run with parameters pCube:%pCube%, pDim:%pDim%, pDimIndex:%pDimIndex%, pIncludeData:%pIncludeData%, pEle:%pEle%, pIncludeRules:%pIncludeRules%, pCtrlObj:%pCtrlObj%, pTemp:%pTemp%.';\r\n\r\n## check operating system\r\nIf( SubSt( GetProcessErrorFileDirectory, 2, 1 ) @= ':' );\r\n  sOS = 'Windows';\r\n  sOSDelim = '\\';\r\nElseIf( Scan( '/', GetProcessErrorFileDirectory ) > 0 );\r\n  sOS = 'Linux';\r\n  sOSDelim = '/';\r\nElse;\r\n  sOS = 'Windows';\r\n  sOSDelim = '\\';\r\nEndIf;\r\n\r\n## LogOutput parameters\r\nIF( pLogoutput = 1 );\r\n    LogOutput('INFO', Expand( cLogInfo ) );   \r\nENDIF;\r\n\r\n### Validate Parameters ###\r\nnErrors = 0;\r\n# Validate cube\r\ncDimCount = 0;\r\nIf( Trim( pCube ) @= '' );\r\n    nErrors = nErrors + 1;\r\n    sMessage = 'No cube specified.';\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nElseIf( CubeExists( pCube ) = 0 );\r\n    nErrors = nErrors + 1;\r\n    sMessage = Expand( 'Invalid cube specified: %pCube%.');\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nElse;\r\n    cDimCount = CubeDimensionCountGet(pCube);\r\nEndIf;\r\n\r\n# Don't allow system cubes to be modified\r\nIf( SubSt( pCube, 1, 1 ) @= '}' & pCtrlObj <= 0 );\r\n    nErrors = nErrors + 1;\r\n    sMessage = Expand( 'Do not modify system cubes: %pCube%.');\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nEndIf;\r\n\r\n# Validate index\r\nIf( pDimIndex = 0 );\r\n    nErrors = nErrors + 1;\r\n    sMessage = Expand( 'Index for new dimension is a REQUIRED parameter!');\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nElseIf( pDimIndex > cDimCount + 1 );\r\n    nErrors = nErrors + 1;\r\n    sMessage = Expand( 'Cube %pCube% has %cDimCount% dimensions. %pDimIndex% is not valid for the new dimension index!');\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nEndIf;\r\n\r\n# Validate dimension\r\nIf( Trim( pDim ) @= '' );\r\n    nErrors = nErrors + 1;\r\n    sMessage = 'No dimension specified.';\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nElseIf( DimensionExists( pDim ) = 0 );\r\n    nErrors = nErrors + 1;\r\n    sMessage = Expand( 'New dimension: %pDim% does not exist');\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nEndIf;\r\n\r\n# check element chosen in new dimension\r\nIf( pIncludeData = 1 & Trim(pEle)@='' );\r\n    nErrors = nErrors + 1;\r\n    sMessage = Expand( 'No element specified in new dimension %pDim% to store cube data.');\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nEndIf;\r\n\r\nIf( pIncludeData = 1 & DIMIX(pDim, pEle)=0 );\r\n    nErrors = nErrors + 1;\r\n    sMessage = Expand( 'Invalid element %pEle% specified for the new dimension %pDim% to store cube data.');\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nEndIf;\r\n\r\nIF(pIncludeRules = 1 % pIncludeRules = 2);\r\n    sRule=CubeRuleGet( pCube );\r\n    If( sRule@= '' );\r\n        pIncludeRules = 0;\r\n        LogOutput( 'INFO', Expand( 'No rule found for %pCube%.' ) );\r\n    Endif;\r\nEndif;  \r\n\r\n### Determine number of dims in source cube & create strings to check and recreate ###\r\nnCount = 1;\r\nsDimString = '';\r\nsDimCheck = '';\r\nsDelim = '+';\r\nnNewFound = 0;\r\nnIncrement = 1;\r\nWhile( TabDim( pCube, nCount ) @<> '' );\r\n  sDim = TabDim( pCube, nCount );\r\n  IF(nCount = pDimIndex & nNewFound = 0);\r\n    sNewDim = pDim;\r\n    nNewFound = 1;\r\n    nIncrement = 0;\r\n  else;\r\n    sNewDim = sDim;\r\n    nIncrement = 1;\r\n  Endif;  \r\n  sDimCheck = sDimCheck|'+'|sDim|'+';\r\n  sDimString = sDimString|'+'|sNewDim;\r\n  nCount = nCount + nIncrement;\r\nEnd;\r\nnDimensionCount = nCount;\r\n\r\n# Cover case of new dimension in last position (pDimIndex = cDimCount+1)\r\nIf( nDimensionCount = pDimIndex & nNewFound = 0 );\r\n    nNewFound = 1;\r\n    sNewDim=pDim;\r\n    sDimString = sDimString|'+'|sNewDim;\r\nEndIf;\r\n\r\n# Remove any leading +\r\nIF( Subst( sDimString , 1 , 1 ) @= '+' );\r\n    sDimString      = Subst ( sDimString , 2, Long(sDimString)-1 );\r\nEndIf;\r\n\r\nIF( Scan('+'|Lower(pDim)|'+', Lower(sDimCheck)) > 0 );\r\n    nErrors = nErrors + 1;\r\n    sMessage = Expand( 'The chosen new dimension %pDim% already exists in cube %pCube%.');\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nEndif;\r\n\r\n# Check if cube exceeds current max dimenions\r\nIf( nDimensionCount > 27 );\r\n    sMessage = 'Process needs to be modified to handle cubes with more than 27 dimensions';\r\n    nErrors = nErrors + 1;\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nEndIf;\r\n\r\n### Check for errors before continuing\r\nIf( nErrors <> 0 );\r\n  If( pStrictErrorHandling = 1 ); \r\n      ProcessQuit; \r\n  Else;\r\n      ProcessBreak;\r\n  EndIf;\r\nEndIf;\r\n\r\n######  CALLING THE STEP PROCESSES #####\r\n\r\n# Keep the rule\r\nIF(pIncludeRules = 1 % pIncludeRules = 2);\r\n  \r\n  sProc = '}bedrock.cube.rule.manage';\r\n  nRet = ExecuteProcess( sProc,\r\n    'pLogOutput', pLogOutput,\r\n    'pStrictErrorHandling', pStrictErrorHandling,\r\n    'pCube', pCube,\r\n    'pMode', 'UNLOAD'\r\n    );\r\n    \r\n  IF(nRet <> 0);\r\n    sMessage = 'Error unloading the rule for %pCube%.';\r\n    nErrors = nErrors + 1;\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n    If( pStrictErrorHandling = 1 ); \r\n        ProcessQuit; \r\n    Else;\r\n        ProcessBreak;\r\n    EndIf;\r\n  ENDIF;\r\n  \r\nEndif; \r\n\r\n# create clone cube with data\r\nIF(pIncludeData = 1);\r\n  \r\n    pCloneCube = pCube | '_Clone';\r\n    nIncludeRules = IF(pIncludeRules = 1 % pIncludeRules = 2, 1, 0);\r\n    nSuppressRules = IF(nIncludeRules = 1,  1, 0);\r\n  \r\n    sProc = '}bedrock.cube.clone';\r\n    nRet = ExecuteProcess( sProc,\r\n        'pLogOutput', pLogOutput,\r\n        'pStrictErrorHandling', pStrictErrorHandling,\r\n        'pSrcCube', pCube,\r\n        'pTgtCube', pCloneCube,\r\n        'pIncludeRules', nIncludeRules,\r\n        'pIncludeData', pIncludeData,\r\n        'pSuppressRules', nSuppressRules,\r\n        'pTemp', pTemp,\r\n        'pCubeLogging', 0\r\n        );\r\n\r\n    IF(nRet <> 0);\r\n        sMessage = 'Error creating cloned cube for keeping data.';\r\n        nErrors = nErrors + 1;\r\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n        If( pStrictErrorHandling = 1 ); \r\n            ProcessQuit; \r\n        Else;\r\n            ProcessBreak;\r\n        EndIf;\r\n    ENDIF;\r\nEndif;\r\n\r\n# recreate the cube\r\nsProc = '}bedrock.cube.create';\r\nnRet = ExecuteProcess( sProc,\r\n    'pLogOutput', pLogOutput,\r\n    'pStrictErrorHandling', pStrictErrorHandling,\r\n    'pCube', pCube,\r\n    'pDims', sDimString,\r\n    'pRecreate', 1,\r\n    'pDelim', sDelim\r\n    );\r\n\r\nIF(nRet <> 0);\r\n    sMessage = Expand('Error recreating the cube: %pCube%.');\r\n    nErrors = nErrors + 1;\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n    If( pStrictErrorHandling = 1 ); \r\n        ProcessQuit; \r\n    Else;\r\n        ProcessBreak;\r\n    EndIf;\r\nENDIF;\r\n\r\n# copy back the data\r\nIF(pIncludeData = 1);\r\n    sEleStartDelim = '\u00a6';\r\n    sMappingToNewDims = pDim|sEleStartDelim|pEle;\r\n  \r\n    nRet = ExecuteProcess('}bedrock.cube.data.copy.intercube',\r\n  \t'pLogOutput',pLogOutput,\r\n  \t'pStrictErrorHandling', pStrictErrorHandling,\r\n  \t'pSrcCube',pCloneCube,\r\n  \t'pFilter','',\r\n  \t'pTgtCube',pCube,\r\n  \t'pMappingToNewDims',sMappingToNewDims,\r\n        'pSuppressConsol', 1,\r\n        'pSuppressRules', nSuppressRules,\r\n  \t'pZeroTarget',0,\r\n  \t'pZeroSource',0,\r\n  \t'pFactor',1,\r\n  \t'pDimDelim','&',\r\n  \t'pEleStartDelim',sEleStartDelim,\r\n  \t'pEleDelim','+',\r\n  \t'pTemp',pTemp,\r\n  \t'pCubeLogging',0);\r\n    \r\n    IF(nRet <> 0);\r\n        sMessage = Expand('Error copying back the data from clone cube: %pCloneCube%.');\r\n        nErrors = nErrors + 1;\r\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n        If( pStrictErrorHandling = 1 ); \r\n            ProcessQuit; \r\n        Else;\r\n            ProcessBreak;\r\n        EndIf;\r\n    ENDIF;\r\n  \r\n    # destroy clone cube\r\n    IF(pTemp=1);\r\n        sProc = '}bedrock.cube.delete';\r\n        nRet = ExecuteProcess( sProc,\r\n            'pLogOutput', pLogOutput,\r\n            'pStrictErrorHandling', pStrictErrorHandling,\r\n            'pCube', pCloneCube,\r\n            'pCtrlObj', 0\r\n            );\r\n\r\n        IF(nRet <> 0);\r\n            sMessage = Expand('Error deleting the clone cube: %pCloneCube%.');\r\n            nErrors = nErrors + 1;\r\n            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n            If( pStrictErrorHandling = 1 ); \r\n                ProcessQuit; \r\n            Else;\r\n                ProcessBreak;\r\n            EndIf;\r\n        ENDIF;\r\n    Endif;\r\n\r\nEndif; \r\n\r\n# reload the rule\r\nIF(pIncludeRules = 2);\r\n  \r\n    sProc = '}bedrock.cube.rule.manage';\r\n\r\n    nRet = ExecuteProcess( sProc,\r\n        'pLogOutput', pLogOutput,\r\n        'pStrictErrorHandling', pStrictErrorHandling,\r\n        'pCube', pCube,\r\n        'pMode', 'LOAD'\r\n        );\r\n    \r\n    IF(nRet <> 0);\r\n      sMessage = Expand('Error reloading the rule for %pCube%.');\r\n      nErrors = nErrors + 1;\r\n      LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n      # Create error rule file \r\n      cErrorRuleName = 'ErrorRuleFile.txt';\r\n      \r\n      IF(FileExists( Lower(cErrorRuleName) ) = 0 );\r\n        sFile = '.' | sOSDelim | Lower(cErrorRuleName);\r\n        LogOutput(cMsgErrorLevel, 'Rule could not be attached due to invalid !Dimension references. Please recover from the backup and fix manually.');\r\n      ENDIF;\r\n      \r\n      ExecuteProcess( sProc,\r\n      'pLogOutput', pLogOutput,\r\n      'pStrictErrorHandling', pStrictErrorHandling,\r\n      'pCube', pCube,\r\n      'pFileName', Lower(cErrorRuleName),\r\n      'pMode', 'LOAD'\r\n      );\r\n      If( pStrictErrorHandling = 1 ); \r\n          ProcessQuit; \r\n      Else;\r\n          ProcessBreak;\r\n      EndIf;\r\n    ENDIF;\r\n  \r\nEndif; \r\n\r\n### End Prolog ###",
  "MetadataProcedure": "\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n",
  "DataProcedure": "\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n",
  "EpilogProcedure": "\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n\r\n################################################################################################# \r\n##~~Join the bedrock TM1 community on GitHub https://github.com/cubewise-code/bedrock Ver 4.0~~##\r\n################################################################################################# \r\n\r\n### Return code & final error message handling\r\nIf( nErrors > 0 );\r\n    sMessage = 'the process incurred at least 1 error. Please see above lines in this file for more details.';\r\n    nProcessReturnCode = 0;\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\r\n    If( pStrictErrorHandling = 1 ); \r\n        ProcessQuit; \r\n    EndIf;\r\nElse;\r\n    sProcessAction = Expand( 'Process:%cThisProcName% successfully added dimension %pDim%.' );\r\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\r\n    nProcessReturnCode = 1;\r\n    If( pLogoutput = 1 );\r\n        LogOutput('INFO', Expand( sProcessAction ) );   \r\n    EndIf;\r\nEndIf;\r\n\r\n### End Epilog ###",
  "HasSecurityAccess": true,
  "UIData": "",
  "DataSource": {
    "Type": "None"
  },
  "Parameters": [
    {
      "Name": "pLogOutput",
      "Prompt": "OPTIONAL: Write parameters and action summary to server message log (Boolean True = 1)",
      "Value": 0,
      "Type": "Numeric"
    },
    {
      "Name": "pStrictErrorHandling",
      "Prompt": "OPTIONAL: On encountering any error, exit with major error status by ProcessQuit after writing to the server message log (Boolean True = 1)",
      "Value": 0,
      "Type": "Numeric"
    },
    {
      "Name": "pCube",
      "Prompt": "REQUIRED: Cube name",
      "Value": "",
      "Type": "String"
    },
    {
      "Name": "pDim",
      "Prompt": "REQUIRED: Dimension to be added",
      "Value": "",
      "Type": "String"
    },
    {
      "Name": "pDimIndex",
      "Prompt": "REQUIRED: Dimension number of the new dimension in the cube",
      "Value": 1,
      "Type": "Numeric"
    },
    {
      "Name": "pIncludeData",
      "Prompt": "OPTIONAL: If 1 then data is kept (copied through clone cube)",
      "Value": 0,
      "Type": "Numeric"
    },
    {
      "Name": "pEle",
      "Prompt": "REQUIRED: if IncludeData flag =1: Element of new dimension where to store data",
      "Value": "",
      "Type": "String"
    },
    {
      "Name": "pIncludeRules",
      "Prompt": "Unload and reload the rule (0 = do not keep the rule, 1 = unload the rule, 2 = unload the rule and reload on new cube)",
      "Value": 2,
      "Type": "Numeric"
    },
    {
      "Name": "pCtrlObj",
      "Prompt": "OPTIONAL: Allow overwrite control cubes (default = 0)",
      "Value": 0,
      "Type": "Numeric"
    },
    {
      "Name": "pTemp",
      "Prompt": "OPTIONAL: Delete the clone cube (1 = delete, 0 = not delete)",
      "Value": 1,
      "Type": "Numeric"
    }
  ],
  "Variables": [],
  "VariablesUIData": []
}