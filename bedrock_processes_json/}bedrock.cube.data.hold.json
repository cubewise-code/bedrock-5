{
  "Name": "}bedrock.cube.data.hold",
  "PrologProcedure": "#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n\r\n# A snippet of code provided as an example how to call this process should the developer be working on a system without access to an editor with auto-complete.\r\nIf( 1 = 0 );\r\n    ExecuteProcess( '}bedrock.cube.data.hold', 'pLogOutput', pLogOutput, 'pStrictErrorHandling', pStrictErrorHandling, \r\n    'pMode', 'C / D / R / X / M', 'pCube', '', 'pClient', '', 'pGroup', '', 'pDelim', '&', 'pDir', '', 'pSkipNonExistentHoldsCubes', 1 );\r\nEndIf;\r\n\r\n#################################################################################################\r\n##~~Join the bedrock TM1 community on GitHub https://github.com/cubewise-code/bedrock-5 Ver 5.0~~##\r\n#################################################################################################\r\n\r\n# Description:\r\n# This TI process can manage TM1 cube holds. Holds are a personal tool for a TM1 user in any TM1 client.\r\n# A hold by client A does not restrict data entry by client B.\r\n# A client needs write access to a cell in order to apply a hold to the cell.\r\n# Existing Bedrock processes are leveraged including their default parameter values.\r\n#\r\n# Use case: Intended for development/prototyping or in Production environment.\r\n# - When a user has applied holds and logs off (or is forced to log off), the holds are lost (even though the Holds cube still exists)\r\n# - When the TM1 model is restarted, all holds are lost (even though the Holds cube still exists)\r\n# - The customer could provide a set of holds to be applied, in several cubes and to several clients and even data entry groups of clients. Applying the holds manually would be tedious.\r\n# - A regular clean up of Holds cubes that are out of date could be wise\r\n#\r\n# Parameters:\r\n# - pLogOutput (standard Bedrock parameter, Boolean True = 1)\r\n# - pStrictErrorHandling (standard Bedrock parameter, Boolean True = 1)\r\n# - pMode (see below). It should be one of: C / D / R / X / M\r\n# - pCube (mandatory). Provide the base cuube name(s), not the Holds cube names! It could be a combination of:\r\n#     * multiple cubes separated with pDelim\r\n#     * wildcards * and ?\r\n#     * the keyword MODELCUBES (the cubes excluding the control cubes)\r\n# - pClient (mandatory or used in conjunction with pGroup). It could be a combination of:\r\n#     * multiple clients separated with pDelim\r\n#     * wildcards * and ?\r\n#     * the keyword MYSELF (the client running this TI process)\r\n# - pGroup (mandatory or used in conjunction with pClient). It could be a combination of:\r\n#     * multiple clients separated with pDelim\r\n#     * wildcards * and ?\r\n#     * the keyword MYGROUPS (the groups that the client running this TI process is a member of)\r\n# - pDelim (standard Bedrock parameter to manage above lists, default value if blank = '&')\r\n# - pDir (only used when exporting or importing flat files. If empty, the error file directory is used. If not existing, an error is returned.)\r\n# - pSkipNonExistentHoldsCubes (not used for mode C) (When using lists and wildcards, it can lead to non-existent holds cubes. Use 1 to skip silently.\r\n#\r\n# Supported functionality related to holds, given the selections made:\r\n# - pMode = C: creation of a holds cube\r\n# - pMode = D: destruction of a holds cube\r\n# - pMode = R: release all holds\r\n# - pMode = X: export of holds to text files\r\n# - pMode = M: import of holds from text files (either new holds to be set, either holds exported earlier)\r\n#\r\n# Note:\r\n# - When exporting holds, the file format will respect the default values of the Bedrock process to export data. The file name is '}Hold_[ClientName]_}}_[CubeName].csv so it matches the Holds cubename.\r\n# - To import holds, the file format needs to respect the default values of the Bedrock process to import data. The file name is '}Hold_[ClientName]_}}_[CubeName].csv so it matches the Holds cubename.\r\n# - When importing holds, the cell value needs to be either H or C\r\n#   * A value of C is to be put in a consolidated cell of the Holds cube\r\n#   * A value of H is to be put in a level 0 cell of the Holds cube\r\n#   * Any other combination will not lead to an error but TM1 will not apply the hold as intended\r\n#   * String cells should not be used in data holds\r\n# - When importing holds, an additional zeroout should be done with a call to this process with mode 'R'\r\n# - The selections for pClient and pGroup will lead to a list of unique clients, to which the selected mode is applied\r\n#   For a group, the members in the group are retrieved, and added to the selected client(s).\r\n# - At least 1 client should be returned from the provided parameter values, if not the process will abort\r\n# - No support for PAW alternate hierarchies\r\n#\r\n###########################################################\r\n\r\n##Global Variables\r\nStringGlobalVariable('sProcessReturnCode');\r\nNumericGlobalVariable('nProcessReturnCode');\r\nnProcessReturnCode = 0;\r\n\r\n### Constants ###\r\ncThisProcName     = GetProcessName();\r\ncTimeStamp        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\r\ncRandomInt        = NumberToString( INT( RAND( ) * 1000 ));\r\ncTempSub          = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\r\ncUserName         = TM1User;\r\ncHoldsCube        = '}Hold_%sClient%_}}_%sCube%';\r\ncMsrDim           = '}Hold';\r\nnCubes            = 0;\r\nnDimMax           = 100;\r\nnErrors           = 0;\r\nsMessage          = '';\r\ncUserName         = TM1User();\r\ncMsgErrorLevel    = 'ERROR';\r\ncMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\r\ncLogInfo          = 'Process:%cThisProcName% run with parameters pCube:%pCube%, pClient:%pClient%, pGroup:%pGroup%, pDelim:%pDelim%, pMode:%pMode%, pDir:%pDir%, pSkipNonExistentHoldsCubes:%pSkipNonExistentHoldsCubes%.' ;\r\n\r\n\r\n#################################################################################################\r\n#Region - Process Parameters\r\n\r\npJson = IF( JsonType( pJson ) @<> 'object', '{}', pJson );\r\nsMessages = '{\"Process\": \"'|GetProcessName()|'\", \"User\": \"'|TM1User()|'\", \"Info\": [\"Process: '''|GetProcessName()|''' run by User: '''|TM1User()|'''.\"], \"Error\": []}';\r\npDefaultParameters = '{\r\n  \"pClient\":                    null,\r\n  \"pCube\":                      null,\r\n  \"pDelim\":                     \"&\",\r\n  \"pDir\":                       \"\",\r\n  \"pGroup\":                     null,\r\n  \"pMode\":                      null,\r\n  \"pLogOutput\":                 0,\r\n  \"pSkipNonExistentHoldsCubes\": 0,\r\n  \"pStrictErrorHandling\":       0\r\n}';\r\n\r\npPassedParameters = '{\r\n  \"pClient\":                    '|StringToJson  ( pClient                    )|',\r\n  \"pCube\":                      '|StringToJson  ( pCube                      )|',\r\n  \"pDelim\":                     '|StringToJson  ( pDelim                     )|',\r\n  \"pDir\":                       '|StringToJson  ( pDir                       )|',\r\n  \"pGroup\":                     '|StringToJson  ( pGroup                     )|',\r\n  \"pMode\":                      '|StringToJson  ( pMode                      )|',\r\n  \"pLogOutput\":                 '|NumberToString( pLogOutput                 )|',\r\n  \"pSkipNonExistentHoldsCubes\": '|NumberToString( pSkipNonExistentHoldsCubes )|',\r\n  \"pStrictErrorHandling\":       '|NumberToString( pStrictErrorHandling       )|'\r\n}';\r\n\r\npJson = JsonMergePatch( pPassedParameters, pJson );\r\n# String Parameters\r\npClient                    =                 JsonToString( JsonGet( pJson, 'pClient'                  ) );\r\npCube                      =                 JsonToString( JsonGet( pJson, 'pCube'                    ) );\r\npDelim                     =                 JsonToString( JsonGet( pJson, 'pDelim'                   ) );\r\npDir                       =                 JsonToString( JsonGet( pJson, 'pDir'                     ) );\r\npGroup                     =                 JsonToString( JsonGet( pJson, 'pGroup'                   ) );\r\npMode                      =                 JsonToString( JsonGet( pJson, 'pMode'                    ) );\r\n# Numeric Parameters\r\npLogOutput                 = StringToNumber( JsonToString( JsonGet( pJson, 'pLogOutput'               ) ) );\r\npSkipNonExistentHoldsCubes = StringToNumber( JsonToString( JsonGet( pJson, 'pSkipNonExistentHoldsCubes' ) ) );\r\npStrictErrorHandling       = StringToNumber( JsonToString( JsonGet( pJson, 'pStrictErrorHandling'     ) ) );\r\n\r\n### Get the parameters that differ from the default\r\npDiffer = JsonDiff( pDefaultParameters, pJson );\r\nnSize = JsonSize( pDiffer );\r\nWHILE( nSize > 0 );\r\n  nSize = nSize - 1;\r\n  pDiffer = JsonReplace( pDiffer, '/'|NumberToString( nSize )|'/op', '\"add\"' );\r\nEND;\r\npJson = JsonPatch( '{}', pDiffer );\r\n\r\n### LogOutput parameters\r\nsMessages = JsonAdd( sMessages, '/Info/-', pJson );\r\nIF( pLogOutput = 1 );\r\n  LogOutput('INFO', JsonToString( sMessages, '/Info/0', 0, ' ' ) );\r\nENDIF;\r\n\r\n#EndRegion - Process Parameters\r\n#################################################################################################\r\n\r\n## LogOutput parameters\r\nIF( pLogOutput = 1 );\r\n    LogOutput('INFO', Expand( cLogInfo ) );\r\nENDIF;\r\n\r\n### Validate Parameters ###\r\nnErrors = 0;\r\n\r\n## Validate the Cube parameter\r\nIf( TRIM(pCube) @= '' );\r\n   sMessage = 'A cube name must be provided.';\r\n   nErrors = nErrors + 1;\r\n   LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nEndIf;\r\n\r\n# If no clients and groups have been specified then terminate process\r\nIf( Trim( pClient ) @= '' & Trim( pGroup ) @= '' );\r\n   nErrors = 1;\r\n   sMessage = 'No clients and groups specified.';\r\n   LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nEndIf;\r\n\r\n# The mode is a restricted list of actions\r\nIf( pMode @<> 'C'\r\n  & pMode @<> 'D'\r\n  & pMode @<> 'R'\r\n  & pMode @<> 'X'\r\n  & pMode @<> 'M' );\r\n    nErrors = 1;\r\n    sMessage = Expand( 'Incorrect value for pMode: %pMode%. Valid values are: C, D, R, X, M.' );\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nElse;\r\n    pMode = Upper( Trim( pMode ));\r\nEndIf;\r\n\r\n# If blank delimiter specified then convert to default\r\nIf( pDelim @= '' );\r\n   pDelim = '&';\r\nEndIf;\r\n\r\n# Skipping non-existent holds cubes\r\nIf( pSkipNonExistentHoldsCubes <> 1 );\r\n   pSkipNonExistentHoldsCubes = 0;\r\nEndIf;\r\n\r\n### Check for errors before continuing\r\nIf( nErrors <> 0 );\r\n  If( pStrictErrorHandling = 1 );\r\n      ProcessQuit;\r\n  Else;\r\n      ProcessBreak;\r\n  EndIf;\r\nEndIf;\r\n\r\n\r\n\r\n# # # # # # # # # #        SEARCH FOR CUBES BY INSPECTING CUBE PARAMETER\r\n# - pCube (mandatory). It could be a combination of:\r\n#     * multiple cubes separated with pDelim\r\n#     * wildcards * and ?\r\n#     * the keyword MODELCUBES (the cubes excluding the control cubes)\r\n\r\n### Split parameter into individual cubes and store in a temporary subset ###\r\nSubsetCreate( '}Cubes', 'Cubes subset', 1 );\r\n\r\nsCubes = pCube;\r\nnDelimiterIndex = 1;\r\nWhile( nDelimiterIndex <> 0 );\r\n   nDelimiterIndex = Scan( pDelim, sCubes );\r\n   If( nDelimiterIndex = 0 );\r\n      sCube = sCubes;\r\n   Else;\r\n      sCube = Trim( SubSt( sCubes, 1, nDelimiterIndex - 1 ) );\r\n      sCubes = Trim( Delet( sCubes, 1, nDelimiterIndex + Long(pDelim) ) );\r\n   EndIf;\r\n\r\n   If( sCube @<> '' );\r\n      # Create subset of cubes. Wildcards could be involved.\r\n\r\n      If( sCube @= 'MODELCUBES' );\r\n         sMDX = '{Except( TM1SubsetAll( [}Cubes] ), TM1FilterByPattern( TM1SubsetAll( [}Cubes] ), \"}*\" ))}';\r\n      Else;\r\n         sMDX = '{TM1FilterByPattern( TM1SubsetAll( [}Cubes] ), \"' | sCube | '\" )}';\r\n      EndIf;\r\n\r\n      If( SubsetExists( '}Cubes', cTempSub ) = 1 );\r\n         # If a delimited list of cube names includes wildcards then we may have to re-use the subset multiple times\r\n         SubsetMDXSet( '}Cubes', cTempSub, sMDX );\r\n      Else;\r\n         # temp subset, therefore no need to destroy in the Epilog tab\r\n         SubsetCreatebyMDX( cTempSub, sMDX, '}Cubes', 1 );\r\n      EndIf;\r\n\r\n      # Loop through the returned cubes, if any\r\n      nCountCubes = 1;\r\n      While( nCountCubes <= SubsetGetSize( '}Cubes', cTempSub ) );\r\n         sCurrCube = SubsetGetElementName( '}Cubes', cTempSub, nCountCubes );\r\n         # Validate cube name\r\n         If( CubeExists( sCurrCube ) = 1 );\r\n            If( SubsetElementExists( '}Cubes', 'Cubes subset', sCurrCube ) = 0 );\r\n               SubsetElementInsert( '}Cubes', 'Cubes subset', sCurrCube, 0 );\r\n            EndIf;\r\n         EndIf;\r\n         nCountCubes = nCountCubes + 1;\r\n      End;\r\n   EndIf;\r\n\r\nEnd;\r\n\r\n# If no cubes found\r\nnFoundCubesCount = SubsetGetSize( '}Cubes', 'Cubes subset' );\r\nIf( nFoundCubesCount = 0 );\r\n   nErrors = 1;\r\n   sMessage = 'No cubes found after processing pCube.';\r\n   LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nElse;\r\n   If( pLogOutput = 1 );\r\n      sMessage = 'Number of cubes found that match pCube: ' | NumberToString( nFoundCubesCount );\r\n      LogOutput('INFO', Expand( sMessage ) );\r\n   EndIf;\r\nEndIf;\r\n\r\n\r\n# # # # # # # # # #        SEARCH FOR CLIENTS BY INSPECTING CLIENTS AND GROUPS PARAMETERS\r\n# - pClient (mandatory or used in conjunction with pGroup). It could be a combination of:\r\n#     * multiple clients separated with pDelim\r\n#     * wildcards * and ?\r\n#     * the keyword MYSELF (the client running this TI process)\r\n\r\n# - pGroup (mandatory or used in conjunction with pClient). It could be a combination of:\r\n#     * multiple clients separated with pDelim\r\n#     * wildcards * and ?\r\n#     * the keyword MYGROUPS (the groups that the client running this TI process is a member of)\r\n\r\n### Split parameter into individual clients and store in a temporary subset ###\r\nSubsetCreate( '}Clients', 'Clients subset', 1 );\r\n\r\nsClients = pClient;\r\nnDelimiterIndex = 1;\r\nWhile( nDelimiterIndex <> 0 );\r\n   nDelimiterIndex = Scan( pDelim, sClients );\r\n   If( nDelimiterIndex = 0 );\r\n      sClient = sClients;\r\n   Else;\r\n      sClient = Trim( SubSt( sClients, 1, nDelimiterIndex - 1 ) );\r\n      sClients = Trim( Delet( sClients, 1, nDelimiterIndex + Long(pDelim) ) );\r\n   EndIf;\r\n\r\n   If( sClient @<> '' );\r\n\r\n      If( sClient @= 'MYSELF' );\r\n         sClient = cUserName;\r\n      EndIf;\r\n\r\n      # Create subset of clients using Wildcard. Wildcards could be involved.\r\n      sMDX = '{TM1FilterByPattern( TM1SubsetAll( [}Clients] ), \"' | sClient | '\" )}';\r\n\r\n      If( SubsetExists( '}Clients', cTempSub ) = 1 );\r\n         # If a delimited list of client names includes wildcards then we may have to re-use the subset multiple times\r\n         SubsetMDXSet( '}Clients', cTempSub, sMDX );\r\n      Else;\r\n         # temp subset, therefore no need to destroy in the Epilog tab\r\n         SubsetCreatebyMDX( cTempSub, sMDX, '}Clients', 1 );\r\n      EndIf;\r\n\r\n      # Loop through the returned clients, if any\r\n      nCountClients = 1;\r\n      While( nCountClients <= SubsetGetSize( '}Clients', cTempSub ) );\r\n         sCurrClient = SubsetGetElementName( '}Clients', cTempSub, nCountClients );\r\n         # Validate client name\r\n         If( Dimix( '}Clients', sCurrClient ) > 0 );\r\n            If( SubsetElementExists( '}Clients', 'Clients subset', sCurrClient ) = 0 );\r\n               SubsetElementInsert( '}Clients', 'Clients subset', sCurrClient, 0 );\r\n            EndIf;\r\n         EndIf;\r\n         nCountClients = nCountClients + 1;\r\n      End;\r\n   EndIf;\r\n\r\nEnd;\r\n\r\n\r\n### Split parameter into individual groups and store in a temporary subset ###\r\nSubsetCreate( '}Groups', 'Groups subset', 1 );\r\n\r\nsGroups = pGroup;\r\nnDelimiterIndex = 1;\r\nWhile( nDelimiterIndex <> 0 );\r\n   nDelimiterIndex = Scan( pDelim, sGroups );\r\n   If( nDelimiterIndex = 0 );\r\n      sGroup = sGroups;\r\n   Else;\r\n      sGroup = Trim( SubSt( sGroups, 1, nDelimiterIndex - 1 ) );\r\n      sGroups = Trim( Delet( sGroups, 1, nDelimiterIndex + Long(pDelim) ) );\r\n   EndIf;\r\n\r\n   If( sGroup @<> '' );\r\n      # Create subset of groups. Wildcards could be involved.\r\n\r\n      If( sGroup @= 'MYGROUPS' );\r\n         sMDX = '{Filter( TM1SubsetAll( [}Groups] ), [}ClientGroups].( [}Clients].[' | cUserName | '] ) <> \"\" )}';\r\n      Else;\r\n         sMDX = '{TM1FilterByPattern( TM1SubsetAll( [}Groups] ), \"' | sGroup | '\" )}';\r\n      EndIf;\r\n\r\n      If( SubsetExists( '}Groups', cTempSub ) = 1 );\r\n         # If a delimited list of group names includes wildcards then we may have to re-use the subset multiple times\r\n         SubsetMDXSet( '}Groups', cTempSub, sMDX );\r\n      Else;\r\n         # temp subset, therefore no need to destroy in the Epilog tab\r\n         SubsetCreatebyMDX( cTempSub, sMDX, '}Groups', 1 );\r\n      EndIf;\r\n\r\n      # Loop through the returned groups, if any\r\n      nCountGroups = 1;\r\n      While( nCountGroups <= SubsetGetSize( '}Groups', cTempSub ) );\r\n         sCurrGroup = SubsetGetElementName( '}Groups', cTempSub, nCountGroups );\r\n         # Validate group name\r\n         If( Dimix( '}Groups', sCurrGroup ) > 0 );\r\n            If( SubsetElementExists( '}Groups', 'Groups subset', sCurrGroup ) = 0 );\r\n               SubsetElementInsert( '}Groups', 'Groups subset', sCurrGroup, 0 );\r\n            EndIf;\r\n         EndIf;\r\n         nCountGroups = nCountGroups + 1;\r\n      End;\r\n   EndIf;\r\n\r\nEnd;\r\nnFoundGroupsCount = SubsetGetSize( '}Groups', 'Groups subset' );\r\n\r\n\r\n# Now rework groups into their clients through the security memberships\r\nIf( nFoundGroupsCount > 0 );\r\n\r\n   # Create subset of clients using Wildcard. Wildcards could be involved.\r\n   sMDX = 'Generate( TM1SubsetToSet([}Groups], \"Groups subset\" ), Filter( TM1SubsetAll([}Clients]), [}ClientGroups].([}Groups].CurrentMember) <> \"\" ))';\r\n   If( SubsetExists( '}Clients', cTempSub ) = 1 );\r\n      SubsetMDXSet( '}Clients', cTempSub, sMDX );\r\n   Else;\r\n      SubsetCreatebyMDX( cTempSub, sMDX, '}Clients', 1 );\r\n   EndIf;\r\n\r\n   # Loop through the returned clients, if any\r\n   nCountClients = 1;\r\n   While( nCountClients <= SubsetGetSize( '}Clients', cTempSub ) );\r\n      sCurrClient = SubsetGetElementName( '}Clients', cTempSub, nCountClients );\r\n      If( SubsetElementExists( '}Clients', 'Clients subset', sCurrClient ) = 0 );\r\n         SubsetElementInsert( '}Clients', 'Clients subset', sCurrClient, 0 );\r\n      EndIf;\r\n      nCountClients = nCountClients + 1;\r\n   End;\r\nEndIf;\r\n\r\n\r\n# If no clients found\r\nnFoundClientsCount = SubsetGetSize( '}Clients', 'Clients subset' );\r\nIf( nFoundClientsCount = 0 );\r\n   nErrors = 1;\r\n   sMessage = 'No clients found after processing pClient and pGroup.';\r\n   LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nElse;\r\n   If( pLogOutput = 1 );\r\n      sMessage = 'Number of clients found that match pClient and pGroup: ' | NumberToString( nFoundClientsCount );\r\n      LogOutput('INFO', Expand( sMessage ) );\r\n   EndIf;\r\nEndIf;\r\n\r\n\r\n### Check for errors before continuing\r\nIf( nErrors <> 0 );\r\n  If( pStrictErrorHandling = 1 );\r\n      ProcessQuit;\r\n  Else;\r\n      ProcessBreak;\r\n  EndIf;\r\nEndIf;\r\n\r\n\r\n# A double loop over cubes and clients to apply the selected action\r\nnCountCubes = 1;\r\nWhile( nCountCubes <= nFoundCubesCount );\r\n   sCube = SubsetGetElementName( '}Cubes', 'Cubes subset', nCountCubes );\r\n   nCubeDimCount = CubeDimensionCountGet( sCube );\r\n\r\n   nCountClients = 1;\r\n   While( nCountClients <= nFoundClientsCount );\r\n      sClient = SubsetGetElementName( '}Clients', 'Clients subset', nCountClients );\r\n\r\n      sHoldsCube = Expand( cHoldsCube );\r\n\r\n\r\n      If( pMode @= 'C' );\r\n\r\n\r\n         # Create a Holds cube\r\n         If( CubeExists( sHoldsCube ) = 1 );\r\n            nErrors = 1;\r\n            sMessage = Expand( 'The holds cube ''%sHoldsCube%'' already exists so it could not be created.' );\r\n            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n            If( pStrictErrorHandling = 1 );\r\n                ProcessQuit;\r\n            Else;\r\n                ProcessBreak;\r\n            EndIf;\r\n         EndIf;\r\n\r\n         If( nCubeDimCount > nDimMax );\r\n            nErrors = 1;\r\n            sMessage = Expand( 'The base cube ''%sCube%'' for the holds cube ''%sHoldsCube%'' contains too many dimensions. ' | NumberToString( nCubeDimCount ) | ' instead of at most ' | NumberToString( nDimMax ) | '.' );\r\n            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n            If( pStrictErrorHandling = 1 );\r\n                ProcessQuit;\r\n            Else;\r\n                ProcessBreak;\r\n            EndIf;\r\n         EndIf;\r\n\r\n         # Create a measures dimension\r\n         If( DimensionExists( cMsrDim ) = 0 );\r\n            If( pLogOutput = 1 );\r\n               sMessage = Expand( 'The measures dimension for hold cubes (%cMsrDim%) does not exist and will be created.' );\r\n               LogOutput('INFO', Expand( sMessage ) );\r\n            EndIf;\r\n            nRet = ExecuteProcess( '}bedrock.hier.create', 'pLogOutput', pLogOutput, 'pStrictErrorHandling', pStrictErrorHandling, 'pDim', cMsrDim );\r\n            If( nRet <> 0 );\r\n               sMessage = Expand( 'Error creating the dimension ''%cMsrDim%''.' );\r\n               nErrors = 1;\r\n               LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n               If( pStrictErrorHandling = 1 );\r\n                  ProcessQuit;\r\n               Else;\r\n                  ProcessBreak;\r\n               EndIf;\r\n            EndIf;\r\n            DimensionElementInsert( cMsrDim, '', 'HoldStatus', 'S' );\r\n         EndIf;\r\n\r\n         # Get the dimension names for the hold cube\r\n         sDims = '';\r\n         d = 1;\r\n         While( d <= nCubeDimCount );\r\n            sDim = Tabdim( sCube, d );\r\n            sDims = sDims | pDelim | sDim;\r\n            d = d + 1;\r\n         End;\r\n         sDims = sDims | pDelim | cMsrDim;\r\n         sDims = Delet( sDims, 1, Long( pDelim ));\r\n\r\n         nRet = ExecuteProcess( '}bedrock.cube.create', 'pLogOutput', pLogOutput, 'pStrictErrorHandling', pStrictErrorHandling,\r\n              'pCube', sHoldsCube, 'pDims', sDims, 'pRecreate', 0, 'pDelim', pDelim );\r\n         If( nRet <> 0 );\r\n            sMessage = Expand( 'Error creating the cube ''%sHoldsCube%''.' );\r\n            nErrors = 1;\r\n            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n            If( pStrictErrorHandling = 1 );\r\n               ProcessQuit;\r\n            Else;\r\n               ProcessBreak;\r\n            EndIf;\r\n         EndIf;\r\n         If( pLogOutput = 1 );\r\n            sMessage = Expand( 'The holds cube ''%sHoldsCube%'' was created.' );\r\n            LogOutput('INFO', Expand( sMessage ) );\r\n         EndIf;\r\n\r\n\r\n      ElseIf( pMode @= 'D' );\r\n\r\n\r\n         # Destroy a Holds cube\r\n         If( CubeExists( sHoldsCube ) = 0 );\r\n            If( pSkipNonExistentHoldsCubes = 0 );\r\n               # nErrors = 1;\r\n               # sMessage = Expand( 'The holds cube ''%sHoldsCube%'' does not exist so it could not be destroyed.' );\r\n               # LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n               # If( pStrictErrorHandling = 1 );\r\n               #     ProcessQuit;\r\n               # Else;\r\n               #     ProcessBreak;\r\n               # EndIf;\r\n               If( pLogOutput = 1 );\r\n                  sMessage = Expand( 'The holds cube ''%sHoldsCube%'' does not exist so it could not be destroyed.' );\r\n                  LogOutput('INFO', Expand( sMessage ) );\r\n               EndIf;\r\n            EndIf;\r\n         Else;\r\n\r\n            CubeDestroy( sHoldsCube );\r\n            If( pLogOutput = 1 );\r\n               sMessage = Expand( 'The holds cube ''%sHoldsCube%'' was destroyed.' );\r\n               LogOutput('INFO', Expand( sMessage ) );\r\n            EndIf;\r\n         EndIf;\r\n\r\n\r\n      ElseIf( pMode @= 'R' );\r\n\r\n\r\n         # In an existing Holds cube, delete all holds (Release)\r\n         If( CubeExists( sHoldsCube ) = 0 );\r\n            If( pSkipNonExistentHoldsCubes = 0 );\r\n               nErrors = 1;\r\n               sMessage = Expand( 'The holds cube ''%sHoldsCube%'' does not exist so all of its holds (if any) could not be released.' );\r\n               LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n               If( pStrictErrorHandling = 1 );\r\n                   ProcessQuit;\r\n               Else;\r\n                   ProcessBreak;\r\n                EndIf;\r\n            EndIf;\r\n         Else;\r\n\r\n            CubeClearData( sHoldsCube );\r\n            # nRet = ExecuteProcess( '}bedrock.cube.data.clear', 'pLogOutput', pLogOutput, 'pStrictErrorHandling', pStrictErrorHandling,\r\n            #    'pCube', sHoldsCube, 'pView', '', 'pFilter', '', 'pSuppressConsolStrings', 0, 'pCubeLogging', 2 );\r\n            # If( nRet <> 0 );\r\n            #    sMessage = 'Error releasing all the holds in the cube ''%sHoldsCube%''.';\r\n            #    nErrors = 1;\r\n            #    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n            #    If( pStrictErrorHandling = 1 );\r\n            #       ProcessQuit;\r\n            #    Else;\r\n            #       ProcessBreak;\r\n            #    EndIf;\r\n            # EndIf;\r\n            If( pLogOutput = 1 );\r\n               sMessage = Expand( 'All the holds in the cube ''%sHoldsCube%'' were released.' );\r\n               LogOutput('INFO', Expand( sMessage ) );\r\n            EndIf;\r\n\r\n         EndIf;\r\n\r\n\r\n      ElseIf( pMode @= 'X' );\r\n\r\n\r\n         # From an existing Holds cube, export all entries\r\n         If( CubeExists( sHoldsCube ) = 0 );\r\n            If( pSkipNonExistentHoldsCubes = 0 );\r\n               nErrors = 1;\r\n               sMessage = Expand( 'The holds cube ''%sHoldsCube%'' does not exist so all of its holds (if any) could not be exported.' );\r\n               LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n               If( pStrictErrorHandling = 1 );\r\n                  ProcessQuit;\r\n               Else;\r\n                  ProcessBreak;\r\n               EndIf;\r\n            EndIf;\r\n         Else;\r\n\r\n            If( nCubeDimCount > nDimMax );\r\n               nErrors = 1;\r\n               sMessage = Expand( 'The base cube ''%sCube%'' for the holds cube ''%sHoldsCube%'' contains too many dimensions. ' | NumberToString( nCubeDimCount ) | ' instead of at most ' | NumberToString( nDimMax ) | '.' );\r\n               LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n               If( pStrictErrorHandling = 1 );\r\n                   ProcessQuit;\r\n               Else;\r\n                   ProcessBreak;\r\n               EndIf;\r\n            EndIf;\r\n\r\n            # the file directory (If empty, the error file directory is used. If not existing, an error is returned.)\r\n            #    this is done by the called Bedrock process\r\n            # the file name is simply the Holds cube name with file extension csv\r\n            sFileName = sHoldsCube | '.csv';\r\n            nRet = ExecuteProcess( '}bedrock.cube.data.export', 'pLogOutput', pLogOutput, 'pStrictErrorHandling', pStrictErrorHandling,\r\n               'pCube', sHoldsCube, 'pView', '', 'pFilter', '', 'pSuppressConsol', 0, 'pSuppressConsolStrings', 0,\r\n               'pCubeLogging', 2, 'pFilePath', pDir, 'pFileName', sFileName );\r\n            If( nRet <> 0 );\r\n               sMessage = Expand( 'Error exporting all the holds from the cube ''%sHoldsCube%'' to a flat file.' );\r\n               nErrors = 1;\r\n               LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n               If( pStrictErrorHandling = 1 );\r\n                  ProcessQuit;\r\n               Else;\r\n                  ProcessBreak;\r\n               EndIf;\r\n            EndIf;\r\n            If( pLogOutput = 1 );\r\n               sMessage = Expand( 'All the holds in the cube ''%sHoldsCube%'' were exported.' );\r\n               LogOutput('INFO', Expand( sMessage ) );\r\n            EndIf;\r\n         EndIf;\r\n\r\n\r\n      ElseIf( pMode @= 'M' );\r\n\r\n\r\n         # To an existing Holds cube, import all entries\r\n         # If the Holds cube does not exist, you need to create it first with mode C\r\n         If( CubeExists( sHoldsCube ) = 0 );\r\n            If( pSkipNonExistentHoldsCubes = 0 );\r\n               nErrors = 1;\r\n               sMessage = Expand( 'The holds cube ''%sHoldsCube%'' does not exist so holds (if any) could not be imported. You might want to create it first using mode ''C''.' );\r\n               LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n               If( pStrictErrorHandling = 1 );\r\n                  ProcessQuit;\r\n               Else;\r\n                  ProcessBreak;\r\n               EndIf;\r\n            EndIf;\r\n         Else;\r\n\r\n            # the file directory (If empty, the error file directory is used. If not existing, an error is returned.)\r\n            #    this is done by the called Bedrock process\r\n            # the file name is simply the Holds cube name with file extension csv\r\n            sFileName = sHoldsCube | '.csv';\r\n            nRet = ExecuteProcess( '}bedrock.cube.data.import', 'pLogOutput', pLogOutput, 'pStrictErrorHandling', pStrictErrorHandling,\r\n               'pCube', sHoldsCube, 'pSrcDir', pDir, 'pSrcFile', sFileName, 'pCubeLogging', 2, 'pFileDelete', 0, 'pSkipInvalidRecords', 0 );\r\n            If( nRet <> 0 );\r\n               sMessage = Expand( 'Error importing all the holds to the cube ''%sHoldsCube%'' from a flat file.' );\r\n               nErrors = 1;\r\n               LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n               If( pStrictErrorHandling = 1 );\r\n                  ProcessQuit;\r\n               Else;\r\n                  ProcessBreak;\r\n               EndIf;\r\n            EndIf;\r\n            If( pLogOutput = 1 );\r\n               sMessage = Expand( 'All the holds were imported to the cube ''%sHoldsCube%''.' );\r\n               LogOutput('INFO', Expand( sMessage ) );\r\n            EndIf;\r\n         EndIf;\r\n      EndIf;\r\n\r\n      nCountClients = nCountClients + 1;\r\n   End;\r\n\r\n   nCountCubes = nCountCubes + 1;\r\nEnd;",
  "MetadataProcedure": "#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n",
  "DataProcedure": "#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n",
  "EpilogProcedure": "#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n\r\n#################################################################################################\r\n##~~Join the bedrock TM1 community on GitHub https://github.com/cubewise-code/bedrock-5 Ver 5.0~~##\r\n#################################################################################################\r\n\r\n### Return code & final error message handling\r\nIf( nErrors > 0 );\r\n   sMessage = 'the process incurred at least 1 error. Please see above lines in this file for more details.';\r\n   nProcessReturnCode = 0;\r\n   LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n   sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\r\n   If( pStrictErrorHandling = 1 );\r\n      ProcessQuit;\r\n   EndIf;\r\nElse;\r\n   sProcessAction = Expand( 'Process:%cThisProcName% successfully performed %pMode% for cube ''%pCube%'', with client ''%pGroup%'' and group ''%pGroup%''.' );\r\n   sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\r\n   nProcessReturnCode = 1;\r\n   If( pLogOutput = 1 );\r\n      LogOutput('INFO', Expand( sProcessAction ) );\r\n   EndIf;\r\nEndIf;",
  "HasSecurityAccess": false,
  "UIData": "",
  "DataSource": {
    "Type": "None"
  },
  "Parameters": [
    {
      "Name": "pMode",
      "Prompt": "REQUIRED: Use C / D / R / X / M. See inside process for information. Supported operations for holds cubes: Create, Destroy, Release, Export, Import.",
      "Value": "",
      "Type": "String"
    },
    {
      "Name": "pCube",
      "Prompt": "REQUIRED: Cube name",
      "Value": "",
      "Type": "String"
    },
    {
      "Name": "pClient",
      "Prompt": "REQUIRED: or used in conjunction with pGroup. Treat the Holds cube(s) of which client(s) ? Supports a list and wildcards * and ? and keyword MYSELF.",
      "Value": "",
      "Type": "String"
    },
    {
      "Name": "pGroup",
      "Prompt": "REQUIRED: or used in conjunction with pClient. Treat the Holds cube(s) of which client(s) in which group(s) ? Delimited list of groups",
      "Value": "",
      "Type": "String"
    },
    {
      "Name": "pDelim",
      "Prompt": "OPTIONAL: Delimiter for list parameters (Default = '&')",
      "Value": "&",
      "Type": "String"
    },
    {
      "Name": "pDir",
      "Prompt": "OPTIONAL: File directory (Default = GetProcessErrorFileDirectory)",
      "Value": "",
      "Type": "String"
    },
    {
      "Name": "pSkipNonExistentHoldsCubes",
      "Prompt": "OPTIONAL: When using lists and wildcards, it can lead to non-existent holds cubes (Boolean. Default = 0)",
      "Value": 0,
      "Type": "Numeric"
    },
    {
      "Name": "pLogOutput",
      "Prompt": "OPTIONAL: Write parameters and action summary to server message log (Boolean. Default = 0)",
      "Value": 0,
      "Type": "Numeric"
    },
    {
      "Name": "pStrictErrorHandling",
      "Prompt": "OPTIONAL: On encountering any error, exit with major error status by ProcessQuit after writing to the server message log (Boolean. Default = 0)",
      "Value": 0,
      "Type": "Numeric"
    },
    {
      "Name": "pJson",
      "Prompt": "OPTIONAL: JSON Object with process parameter values. This will overwrite user passed parameters for all included parameters.",
      "Value": "{}",
      "Type": "String"
    }
  ],
  "Variables": [],
  "VariablesUIData": []
}