{
  "Name": "}bedrock.security.evaluate.mdx.private",
  "PrologProcedure": "#Region CallThisProcess\r\n# A snippet of code provided as an example how to call this process should the developer be working on a system without access to an editor with auto-complete.\r\nIf( 1 = 0 );\r\n    ExecuteProcess('}bedrock.security.evaluate.mdx.private',\r\n       'pLogOutput', pLogOutput,\r\n       'pStrictErrorHandling', pStrictErrorHandling,\r\n       'pUser', pUser,\r\n       'pDimension', pDimension,\r\n       'pSubset', pSubset,\r\n       'pSubsetFile', pSubsetFile,\r\n       'pFilePath', pFilePath,\r\n       'pFileName', pFileName,\r\n       'pDelim', pDelim,\r\n       'pQuote', pQuote\r\n      );\r\nEndIf;\r\n#EndRegion CallThisProcess\r\n\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n\r\n################################################################################################# \r\n##~~Join the bedrock TM1 community on GitHub https://github.com/cubewise-code/bedrock-5 Ver 5.0~~##\r\n################################################################################################# \r\n\r\n#Region @DOC\r\n# Description:\r\n# This process will find out PRIVATE dynamic subsets of dimensions having security on them - element security - and evaluate expressions impacted by the latest MDX security changes \r\n\r\n# Use case: Intended for development or production.\r\n\r\n# Note:\r\n# \r\n#EndRegion @DOC\r\n\r\n##Global Variables\r\nStringGlobalVariable('sProcessReturnCode');\r\nNumericGlobalVariable('nProcessReturnCode');\r\nStringGlobalVariable('sGlobPrivateSubsetsTotalString');\r\nnProcessReturnCode= 0;\r\n\r\n### Constants ###\r\ncThisProcName       = GetProcessName();\r\ncTimeStamp          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\r\ncRandomInt          = NumberToString( INT( RAND( ) * 1000 ));\r\ncUserName           = TM1User();\r\ncMsgErrorLevel      = 'ERROR';\r\ncMsgErrorContent    = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\r\ncLogInfo            = 'Process:%cThisProcName% run with parameters pUser:%pUser%, pDimension:%pDimension%, pSubset:%pSubset%, pSubsetFile:%pSubsetFile%, pFilePath:%pFilePath%, pFileName:%pFileName%, pDelim:%pDelim%, pQuote:%pQuote%.' ;  \r\ncMsgInfoContent    = 'User:%cUserName% Process:%cThisProcName% InfoMsg:%sMessage%';\r\ncSecurityPrefix = '}ElementSecurity_';\r\ncDimDim = '}Dimensions';\r\ncUserDim = '}Clients';\r\ncUserAttrDim= '}ElementAttributes_}Clients';\r\ncUserAlias = '}TM1_DefaultDisplayValue';\r\ncSubsetPrefix = '}Subsets_';\r\ncGroupDim = '}Groups';\r\ncSecCube = '}ClientGroups';\r\nnGroupMax = DimSiz ( cGroupDim );\r\nnUserMax = DimSiz ( cUserDim );\r\ncEleSecCube = cSecurityPrefix | pDimension;\r\n\r\n#################################################################################################\r\n#Region - Process Parameters\r\n\r\npJson = IF( JsonType( pJson ) @<> 'object', '{}', pJson );\r\nsMessages = '{\"Process\": \"'|GetProcessName()|'\", \"User\": \"'|TM1User()|'\", \"Info\": [\"Process: '''|GetProcessName()|''' run by User: '''|TM1User()|'''.\"], \"Error\": []}';\r\npDefaultParameters = '{\r\n  \"pDelim\":               \"&\",\r\n  \"pDimension\":           null,\r\n  \"pFileName\":            \"\",\r\n  \"pFilePath\":            \"\",\r\n  \"pQuote\":               \"\"\",\r\n  \"pSubset\":              null,\r\n  \"pSubsetFile\":          null,\r\n  \"pUser\":                null,\r\n  \"pLogOutput\":           0,\r\n  \"pStrictErrorHandling\": 0,\r\n  \"pWriteOutput\":         1\r\n}';\r\n\r\npPassedParameters = '{\r\n  \"pDelim\":               '|StringToJson  ( pDelim               )|',\r\n  \"pDimension\":           '|StringToJson  ( pDimension           )|',\r\n  \"pFileName\":            '|StringToJson  ( pFileName            )|',\r\n  \"pFilePath\":            '|StringToJson  ( pFilePath            )|',\r\n  \"pQuote\":               '|StringToJson  ( pQuote               )|',\r\n  \"pSubset\":              '|StringToJson  ( pSubset              )|',\r\n  \"pSubsetFile\":          '|StringToJson  ( pSubsetFile          )|',\r\n  \"pUser\":                '|StringToJson  ( pUser                )|',\r\n  \"pLogOutput\":           '|NumberToString( pLogOutput           )|',\r\n  \"pStrictErrorHandling\": '|NumberToString( pStrictErrorHandling )|',\r\n  \"pWriteOutput\":         '|NumberToString( pWriteOutput         )|'\r\n}';\r\n\r\npJson = JsonMergePatch( pPassedParameters, pJson );\r\n# String Parameters\r\npDelim               =                 JsonToString( JsonGet( pJson, 'pDelim'             ) );\r\npDimension           =                 JsonToString( JsonGet( pJson, 'pDimension'         ) );\r\npFileName            =                 JsonToString( JsonGet( pJson, 'pFileName'          ) );\r\npFilePath            =                 JsonToString( JsonGet( pJson, 'pFilePath'          ) );\r\npQuote               =                 JsonToString( JsonGet( pJson, 'pQuote'             ) );\r\npSubset              =                 JsonToString( JsonGet( pJson, 'pSubset'            ) );\r\npSubsetFile          =                 JsonToString( JsonGet( pJson, 'pSubsetFile'        ) );\r\npUser                =                 JsonToString( JsonGet( pJson, 'pUser'              ) );\r\n# Numeric Parameters\r\npLogOutput           = StringToNumber( JsonToString( JsonGet( pJson, 'pLogOutput'         ) ) );\r\npStrictErrorHandling = StringToNumber( JsonToString( JsonGet( pJson, 'pStrictErrorHandling' ) ) );\r\npWriteOutput         = StringToNumber( JsonToString( JsonGet( pJson, 'pWriteOutput'       ) ) );\r\n\r\n### Get the parameters that differ from the default\r\npDiffer = JsonDiff( pDefaultParameters, pJson );\r\nnSize = JsonSize( pDiffer );\r\nWHILE( nSize > 0 );\r\n  nSize = nSize - 1;\r\n  pDiffer = JsonReplace( pDiffer, '/'|NumberToString( nSize )|'/op', '\"add\"' );\r\nEND;\r\npJson = JsonPatch( '{}', pDiffer );\r\n\r\n### LogOutput parameters\r\nsMessages = JsonAdd( sMessages, '/Info/-', pJson );\r\nIF( pLogOutput = 1 );\r\n  LogOutput('INFO', JsonToString( sMessages, '/Info/0', 0, ' ' ) );\r\nENDIF;\r\n\r\n#EndRegion - Process Parameters\r\n#################################################################################################\r\n\r\npFieldDelim       = TRIM(pDelim);\r\nsCRLF             = Char( 13 ) | Char( 10 );\r\ncLenASCIICode     = 3;\r\nnDataCount        = 0;\r\nnErrors           = 0;\r\n\r\n#reset flag and string\r\nnMDXFlag = 0;\r\nsMDX = '';\r\nsTotalRowString = '';\r\n\r\n#keywords to look out for in an MDX expression\r\ncKeyWordList = 'DRILLDOWN&.Children&FirstChild&Ancestors&Ascendants&Cousin&DrillUp&FirstSibling&IsAncestor&FirstSibling&LastChild&LastSibling&Descendants';\r\ncKeyWordList = UPPER ( cKeyWordList );\r\ncKeyWordDelimiter = '&';\r\n\r\n## LogOutput parameters\r\nIF( pLogoutput = 1 );\r\n    LogOutput('INFO', Expand( cLogInfo ) );   \r\nENDIF;\r\n\r\n### Validate Parameters ###\r\n\r\n# Validate user\r\nIF( DimIx( cUserDim,  pUser) = 0 );\r\n    sMessage = Expand('Invalid user: %pUser%');\r\n    nErrors = nErrors + 1;\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nENDIF;\r\n\r\n# Validate dimension\r\nIF( DimIx( cDimDim,  pDimension) = 0 );\r\n    sMessage = Expand('Invalid dimension: %pDimension%');\r\n    nErrors = nErrors + 1;\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nENDIF;\r\n\r\n# Validate subset name\r\nIF( pSubset @= '' % Scan( pSubset, pSubsetFile ) = 0  );\r\n    sMessage = Expand('Invalid subset name: %pSubset%');\r\n    nErrors = nErrors + 1;\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nENDIF;\r\n\r\n## check operating system\r\nIf( SubSt( GetProcessErrorFileDirectory, 2, 1 ) @= ':' );\r\n  sOS = 'Windows';\r\n  sOSDelim = '\\';\r\nElseIf( Scan( '/', GetProcessErrorFileDirectory ) > 0 );\r\n  sOS = 'Linux';\r\n  sOSDelim = '/';\r\nElse;\r\n  sOS = 'Windows';\r\n  sOSDelim = '\\';\r\nEndIf;\r\n\r\n# Validate file path\r\nIf(Trim( pFilePath ) @= '' );\r\n    pFilePath = GetProcessErrorFileDirectory;\r\nEndIf;\r\nIf( SubSt( pFilePath, Long( pFilePath ), 1 ) @= sOSDelim );\r\n    pFilePath = SubSt( pFilePath, 1, Long( pFilePath ) -1 );\r\nEndIf;\r\nIf(  FileExists( pFilePath ) = 0 );\r\n    sMessage = Expand('Invalid export directory: %pFilePath%');\r\n    nErrors = nErrors + 1;\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nEndIf;\r\npFilePath = pFilePath | sOSDelim;\r\n\r\n# Validate file name\r\nIf( pFileName @= '' );\r\n    sBaseFileName = Expand('%cThisProcName%_%pUser%_%pDimension%_%pSubset%_Export');\r\n    sExt = '.csv';\r\n    pFileName = sBaseFileName | '.csv';\r\nElse;\r\n    # determine file extension. If no file extension entered then use .csv as default\r\n    If( Scan( '.', pFileName ) = 0 );\r\n        sExt = '.csv';\r\n        sBaseFileName = pFileName;\r\n    Else;\r\n        sExt = SubSt( pFileName, Scan( '.', pFileName ), Long( pFileName ) );\r\n        sBaseFileName = SubSt( pFileName, 1, Scan( '.', pFileName ) - 1 );\r\n    EndIf;\r\n    pFileName = sBaseFileName | sExt;\r\nEndIf;\r\ncExportFile = pFilePath | pFileName;\r\n\r\n# Validate file delimiter & quote character\r\nIf( pFieldDelim @= '' );\r\n    pFieldDelim = ',';\r\nElse;\r\n    # If length of pFieldDelim is exactly 3 chars and each of them is decimal digit, then the pFieldDelim is entered as ASCII code\r\n    nValid = 0;\r\n    If ( LONG(pFieldDelim) = cLenASCIICode );\r\n      nChar = 1;\r\n      While ( nChar <= cLenASCIICode );\r\n        If( CODE( pFieldDelim, nChar ) >= CODE( '0', 1 ) & CODE( pFieldDelim, nChar ) <= CODE( '9', 1 ) );\r\n          nValid = 1;\r\n        Else;\r\n          nValid = 0;\r\n        EndIf;\r\n        nChar = nChar + 1;\r\n      End;\r\n    EndIf;\r\n    If ( nValid<>0 );\r\n      pFieldDelim=CHAR(StringToNumber( pFieldDelim ));\r\n    Else;\r\n      pFieldDelim = SubSt( Trim( pFieldDelim ), 1, 1 );\r\n    EndIf;\r\nEndIf;\r\nIf( pQuote @= '' );\r\n    ## Use no quote character \r\nElse;\r\n    # If length of pQuote is exactly 3 chars and each of them is decimal digit, then the pQuote is entered as ASCII code\r\n    nValid = 0;\r\n    If ( LONG(pQuote) = cLenASCIICode );\r\n      nChar = 1;\r\n      While ( nChar <= cLenASCIICode );\r\n        If( CODE( pQuote, nChar ) >= CODE( '0', 1 ) & CODE( pQuote, nChar ) <= CODE( '9', 1 ) );\r\n          nValid = 1;\r\n        Else;\r\n          nValid = 0;\r\n        EndIf;\r\n        nChar = nChar + 1;\r\n      End;\r\n    EndIf;\r\n    If ( nValid<>0 );\r\n      pQuote=CHAR(StringToNumber( pQuote ));\r\n    Else;\r\n      pQuote = SubSt( Trim( pQuote ), 1, 1 );\r\n    EndIf;\r\nEndIf;\r\n\r\n# Validate subset file\r\n\r\nIf ( FileExists( pSubsetFile ) = 0 );\r\n    sMessage = Expand('Invalid subset file: %pSubsetFile%');\r\n    nErrors = nErrors + 1;\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nEndIf;\r\n\r\n### Check for errors before continuing\r\nIf( nErrors <> 0 );\r\n  If( pStrictErrorHandling = 1 ); \r\n      ProcessQuit; \r\n  Else;\r\n      ProcessBreak;\r\n  EndIf;\r\nEndIf;\r\n\r\n### Initialize output\r\n\r\nsTotalOutputRowString = '';\r\nIF( pWriteOutput <> 0 );\r\n  sTitleRow = '%pQuote%DIMENSION%pQuote%%pFieldDelim%%pQuote%HAS SECURITY%pQuote%%pFieldDelim%%pQuote%SUBSET NAME%pQuote%';\r\n  sTitleRow = sTitleRow|'%pFieldDelim%%pQuote%IS PRIVATE%pQuote%%pFieldDelim%%pQuote%MDX EXPRESSION%pQuote%';\r\n  sTitleRow = sTitleRow|'%pFieldDelim%%pQuote%KEYWORDS%pQuote%%pFieldDelim%%pQuote%ELEMENTS%pQuote%%pFieldDelim%%pQuote%USERS WITH NO ACCESS%pQuote%';\r\n  sTotalOutputRowString = Expand(sTitleRow);\r\nENDIF;\r\nsRow = '';\r\n\r\n### Assign data source\r\nIf( nErrors = 0 );\r\n    DataSourceType ='CHARACTERDELIMITED';\r\n    DatasourceNameForServer = pSubsetFile;\r\n    DatasourceASCIIDelimiter='@@';\r\nEndIF;\r\n",
  "MetadataProcedure": "#****Begin: Generated Statements***\r\n#****End: Generated Statements****",
  "DataProcedure": "#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n\r\n# MDX statement flag ends on 278\r\n\r\nIf ( Subst ( vLine, 1, 3 ) @= '278' );\r\n    # parse this MDX for keywords\r\n    sKeyWordString = '';\r\n    nKeywordFlag = 0;\r\n    sKeywordList = cKeywordList;\r\n    nKeywordLength = Long ( sKeywordList );\r\n    While ( nKeywordLength > 0 );\r\n        nDelimiter = Scan ( cKeywordDelimiter, sKeyWordList );\r\n        If ( nDelimiter = 0 );\r\n            sKeyword = sKeyWordList;\r\n            sKeyWordList = '';\r\n        Else;\r\n            nEnd = nDelimiter - 1;\r\n            sKeyWord = SubSt ( sKeywordList, 1, nEnd );\r\n            sKeyWordList = Subst ( sKeywordList, nEnd + 2, nKeywordLength - nEnd);\r\n        EndIf;    \r\n\r\n        If ( Scan( sKeyWord, sMDX ) > 0 );\r\n            nKeyWordFlag = nKeyWordFlag + 1;\r\n            IF( Long( sKeyWordString ) = 0 );\r\n              sKeyWordString = sKeyWordString | sKeyWord;\r\n            ELSE;\r\n              sKeyWordString = sKeyWordString | pDelim | ' ' | sKeyWord;\r\n            ENDIF;\r\n            IF( pLogoutput = 1 );\r\n                sMessage = 'Keyword ' | sKeyWord | ' found in ' |sMDX;\r\n                LogOutput('INFO', Expand( cMsgInfoContent ) );\r\n            ENDIF;\r\n        EndIf;   \r\n        nKeywordLength = Long ( sKeywordList );\r\n    End;\r\n    IF( sKeyWordString @<> '' );\r\n        sRow = '%pQuote%%pDimension%%pQuote%%pFieldDelim%%pQuote%Y%pQuote%%pFieldDelim%%pQuote%%pSubset%%pQuote%%pFieldDelim%%pQuote%%pUser%%pQuote%';\r\n        sRow = sRow|'%pFieldDelim%%pQuote%%sMDX%%pQuote%';\r\n        sRow = sRow|'%pFieldDelim%%pQuote%%sKeyWordString%%pQuote%';\r\n    ENDIF;\r\n    # end parsing for keywords\r\n    # if keywords found then see if we can match an element in the MDX with one in the dimension\r\n    # element will be included within [] but there will be [dimension][hierarchy][subset][attribute] so could be a false positive\r\n    sElementString = '';\r\n    sUsersString = '';\r\n    If ( nKeyWordFlag > 0 );\r\n        sMDXTemp = sMDX;\r\n        sStarter = '[';\r\n        sEnder = ']';\r\n        nMDXLength = Long ( sMDXTemp );\r\n        While ( nMDXLength > 0 );\r\n            nStarter = SCAN ( sStarter, sMDXTemp );\r\n            If ( nStarter > 0 );\r\n                nEnder = SCAN ( sEnder, sMDXTemp );\r\n                sElement = SubSt ( sMDXTemp, nStarter + 1, nEnder - nStarter -1);\r\n                nToGo = nMDXLength - nEnder + 1;\r\n                sMDXTemp = Subst ( sMDXTemp, nEnder + 1, nToGo );\r\n                # check if that is actually an element\r\n                If ( DimIx ( pDimension, sElement ) > 0 );\r\n                    IF( Scan( sElement, sElementString ) = 0 );\r\n                        IF( sElementString @= '' );\r\n                            sElementString = sElementString | sElement;\r\n                        ELSE;\r\n                            sElementString = sElementString | pDelim | ' ' | sElement;\r\n                        ENDIF;\r\n                    ENDIF;\r\n                    IF( pLogoutput = 1 );\r\n                        sMessage = sElement | ' is referenced in the MDX and exists in the dimension';\r\n                        LogOutput('INFO', Expand( cMsgInfoContent ) );\r\n                    ENDIF;\r\n                    # now need to loop through relevant groups to see access\r\n                    # loop through all groups to check access to this element\r\n                    nUserCheck = 0;\r\n                    iGroup = 1;\r\n                    While ( iGroup <= nGroupMax );\r\n                        sGroup = DimNm ( cGroupDim, iGroup );\r\n                        #skip the admin groups!\r\n                        If ( sGroup @<> 'ADMIN' & sGroup @<> 'SecurityAdmin' & sGroup @<> 'DataAdmin' & sGroup @<> 'OperationsAdmin' );\r\n                            nCheck = 1;\r\n                            # if we have a user check membership and we don;t need to continue if not in that group\r\n                            If ( CellGetS ( cSecCube, pUser, sGroup ) @= '' );\r\n                                nCheck = 0;\r\n                            EndIf;    \r\n                            If ( nCheck = 1 );\r\n                                # get the groups security assignment\r\n                                sAccess = CellGetS ( cEleSecCube, sElement, sGroup );\r\n                                # if the user has rights to that element then all is good and we can quit the loops\r\n                                If ( sAccess @<> '' & sAccess @<> 'NONE' );\r\n                                    nUserCheck = 1;\r\n                                    iGroup = nGroupMax + 1;\r\n                                EndIf;\r\n                            EndIf;\r\n                        Else;\r\n                            # if the user is in an admin group them they will have access\r\n                            If ( CellGetS ( cSecCube, pUser, sGroup ) @<> '' );\r\n                                nUserCheck = 1;\r\n                            EndIf;       \r\n                        EndIf;    \r\n                        iGroup = iGroup + 1;\r\n                    End;    \r\n                    If ( nUserCheck = 0 );\r\n                        sAlias = AttrS ( cUserDim, pUser, cUserAlias );\r\n                        If ( sAlias @= '' );\r\n                            sAlias = pUser;\r\n                        EndIf;\r\n                        IF( Scan( sAlias, sUsersString ) = 0 );\r\n                            IF( sUsersString @= '' );\r\n                              sUsersString = sUsersString | sAlias;\r\n                            ELSE;\r\n                              sUsersString = sUsersString | pDelim | ' ' | sAlias;\r\n                            ENDIF;\r\n                        ENDIF;\r\n                        IF( pLogoutput = 1 );\r\n                            sMessage = Expand('Private subset %pSubset% contains a keyword and a specific element %sElement% that the user %sAlias% do not have access to');\r\n                            LogOutput('INFO', Expand( cMsgInfoContent ) );\r\n                        ENDIF;\r\n                    EndIf;\r\n                EndIf;\r\n                nMDXLength = Long ( sMDXTemp );\r\n            Else;\r\n                nMDXLength = 0;\r\n            EndIf;    \r\n        End;  \r\n    sRow = sRow|'%pFieldDelim%%pQuote%%sElementString%%pQuote%%pFieldDelim%%pQuote%%sUsersString%%pQuote%';\r\n    EndIf;\r\n    nMDXFlag = 0;\r\n    IF( sTotalOutputRowString @= '' );\r\n        sTotalOutputRowString = Expand(sRow);\r\n    ELSE;\r\n        sTotalOutputRowString = sTotalOutputRowString | sCRLF | Expand(sRow);\r\n    ENDIF;\r\nEndIf;\r\n\r\n\r\nIf ( nMDXFlag = 1 );\r\n    sMDX = UPPER ( sMDX | vLine ); \r\nEndIf;    \r\n\r\n# MDX statement flag starts on 275\r\n\r\nIf ( Subst ( vLine, 1, 3 ) @= '275' );\r\n    nMDXFlag = 1;\r\nEndIf;",
  "EpilogProcedure": "\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n\r\n################################################################################################# \r\n##~~Join the bedrock TM1 community on GitHub https://github.com/cubewise-code/bedrock-5 Ver 5.0~~##\r\n################################################################################################# \r\n\r\n### Write Output data\r\nIf( nErrors = 0 );\r\n  IF( pWriteOutput <> 0 );\r\n      DatasourceAsciiQuoteCharacter = '';\r\n      TextOutput( cExportFile, Expand(sTotalOutputRowString) );\r\n  ELSE;\r\n      IF( sGlobPrivateSubsetsTotalString @= '' );\r\n          sGlobPrivateSubsetsTotalString = sTotalOutputRowString;\r\n      ELSE;\r\n          IF( sTotalOutputRowString @<> '' );\r\n              sGlobPrivateSubsetsTotalString = sGlobPrivateSubsetsTotalString | sCRLF | sTotalOutputRowString;\r\n          ENDIF;\r\n      ENDIF;\r\n  ENDIF;\r\nENDIF;\r\n\r\n### Return code & final error message handling\r\nIf( nErrors > 0 );\r\n    sMessage = 'the process incurred at least 1 error. Please see above lines in this file for more details.';\r\n    nProcessReturnCode = 0;\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\r\n    If( pStrictErrorHandling = 1 ); \r\n        ProcessQuit; \r\n    EndIf;\r\nElse;\r\n    sProcessAction = Expand( 'Process:%cThisProcName% successfully executed.' );\r\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\r\n    nProcessReturnCode = 1;\r\n    If( pLogoutput = 1 );\r\n        LogOutput('INFO', Expand( sProcessAction ) );   \r\n    EndIf;\r\nEndIf;\r\n\r\n### End Epilog ###",
  "HasSecurityAccess": false,
  "UIData": "",
  "DataSource": {
    "Type": "ASCII",
    "asciiDecimalSeparator": ".",
    "asciiDelimiterChar": "@",
    "asciiDelimiterType": "Character",
    "asciiHeaderRecords": 1,
    "asciiQuoteCharacter": "\"",
    "asciiThousandSeparator": ",",
    "dataSourceNameForClient": "Admin\\store}subs\\Euros.sub",
    "dataSourceNameForServer": "Admin/store}subs/Euros.sub"
  },
  "Parameters": [
    {
      "Name": "pUser",
      "Prompt": "REQUIRED: User name",
      "Value": "",
      "Type": "String"
    },
    {
      "Name": "pDimension",
      "Prompt": "REQUIRED: Dimension name",
      "Value": "",
      "Type": "String"
    },
    {
      "Name": "pSubset",
      "Prompt": "REQUIRED: Subset name",
      "Value": "",
      "Type": "String"
    },
    {
      "Name": "pSubsetFile",
      "Prompt": "REQUIRED: Path to subset file",
      "Value": "",
      "Type": "String"
    },
    {
      "Name": "pFilePath",
      "Prompt": "OPTIONAL: File directory (Default = GetProcessErrorFileDirectory)",
      "Value": "",
      "Type": "String"
    },
    {
      "Name": "pFileName",
      "Prompt": "OPTIONAL: File name (Default = pCube | '_Export.csv')",
      "Value": "",
      "Type": "String"
    },
    {
      "Name": "pDelim",
      "Prompt": "OPTIONAL: Delimiter for list parameters (Default = '&')",
      "Value": "&",
      "Type": "String"
    },
    {
      "Name": "pQuote",
      "Prompt": "OPTIONAL: Quote character (2 or 3 digits = ASCII code. Default = '\"')",
      "Value": "\"",
      "Type": "String"
    },
    {
      "Name": "pLogOutput",
      "Prompt": "OPTIONAL: Write parameters and action summary to server message log (Boolean. Default = 0)",
      "Value": 0,
      "Type": "Numeric"
    },
    {
      "Name": "pStrictErrorHandling",
      "Prompt": "OPTIONAL: On encountering any error, exit with major error status by ProcessQuit after writing to the server message log (Boolean. Default = 0)",
      "Value": 0,
      "Type": "Numeric"
    },
    {
      "Name": "pWriteOutput",
      "Prompt": "DO NOT USE: Internal parameter only, please do not use",
      "Value": 1,
      "Type": "Numeric"
    },
    {
      "Name": "pJson",
      "Prompt": "OPTIONAL: JSON Object with process parameter values. This will overwrite user passed parameters for all included parameters.",
      "Value": "{}",
      "Type": "String"
    }
  ],
  "Variables": [
    {
      "Name": "vLine",
      "Type": "String",
      "Position": 1,
      "StartByte": 0,
      "EndByte": 0
    }
  ],
  "VariablesUIData": []
}