{
  "Name": "}bedrock.cube.rule.manage",
  "PrologProcedure": "#Region CallThisProcess\r\n# A snippet of code provided as an example how to call this process should the developer be working on a system without access to an editor with auto-complete.\r\nIf( 1 = 0 );\r\n    ExecuteProcess( '}bedrock.cube.rule.manage', 'pLogOutput', pLogOutput,\r\n      'pStrictErrorHandling', pStrictErrorHandling,\r\n    \t'pCube', '', 'pMode', '',\r\n    \t'pFileName', '', 'pDelim','&', \r\n    \t'pPath', ''\r\n\t);\r\nEndIf;\r\n#EndRegion CallThisProcess\r\n\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n\r\n################################################################################################# ####################\r\n##~~Join the bedrock TM1 community on GitHub https://github.com/cubewise-code/bedrock-5 Ver 5.0~~##\r\n################################################################################################# \r\n\r\n#Region @DOC\r\n# Description:\r\n# This process will backup & remove **OR** re-attach the rule file to cube.\r\n\r\n# Use case: Intended to be used in production.\r\n# 1/ Remove rule file before data load to speed up data load.\r\n# 2/ Re-attach rule file after data load.\r\n\r\n# Note:\r\n# Naturally, a valid cube name (pCube) is mandatory otherwise the process will abort.\r\n# The mandatory pMode parameter must be set to 'Unload' to remove/unload the rule file.\r\n# The pMode parameter must be set to 'Load' to re-attach the rule file and apply the rules.\r\n#EndRegion @DOC\r\n\r\n##Global Variables\r\nStringGlobalVariable('sProcessReturnCode');\r\nNumericGlobalVariable('nProcessReturnCode');\r\nnProcessReturnCode= 0;\r\n\r\n### Constants ###\r\n\r\ncThisProcName       = GetProcessName();\r\ncTimeStamp          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\r\ncRandomInt          = NumberToString( INT( RAND( ) * 1000 ));\r\ncTempSub            = cThisProcName | '_' | cTimeStamp | '_' | cRandomInt;\r\ncCubeDim            = '}Cubes';\r\ncCubeHier           = cCubeDim;\r\nsPath               = '';\r\ncUserName           = TM1User();\r\ncMsgErrorLevel      = 'ERROR';\r\ncMsgErrorContent    = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\r\ncLogInfo            = 'Process:%cThisProcName% run with parameters pCube:%pCube%, pMode:%pMode%, pFileName:%pFileName%, pDelim:%pDelim%, pPath:%pPath%.' ;  \r\ncDimCubes           = '}Cubes';\r\n\r\n#################################################################################################\r\n#Region - Process Parameters\r\n\r\npJson = IF( JsonType( pJson ) @<> 'object', '{}', pJson );\r\nsMessages = '{\"Process\": \"'|GetProcessName()|'\", \"User\": \"'|TM1User()|'\", \"Info\": [\"Process: '''|GetProcessName()|''' run by User: '''|TM1User()|'''.\"], \"Error\": []}';\r\npDefaultParameters = '{\r\n  \"pCube\":                null,\r\n  \"pDelim\":               \"&\",\r\n  \"pFileName\":            \"\",\r\n  \"pMode\":                null,\r\n  \"pPath\":                \"\",\r\n  \"pLogOutput\":           0,\r\n  \"pStrictErrorHandling\": 0\r\n}';\r\n\r\npPassedParameters = '{\r\n  \"pCube\":                '|StringToJson  ( pCube                )|',\r\n  \"pDelim\":               '|StringToJson  ( pDelim               )|',\r\n  \"pFileName\":            '|StringToJson  ( pFileName            )|',\r\n  \"pMode\":                '|StringToJson  ( pMode                )|',\r\n  \"pPath\":                '|StringToJson  ( pPath                )|',\r\n  \"pLogOutput\":           '|NumberToString( pLogOutput           )|',\r\n  \"pStrictErrorHandling\": '|NumberToString( pStrictErrorHandling )|'\r\n}';\r\n\r\npJson = JsonMergePatch( pPassedParameters, pJson );\r\n# String Parameters\r\npCube                =                 JsonToString( JsonGet( pJson, 'pCube'              ) );\r\npDelim               =                 JsonToString( JsonGet( pJson, 'pDelim'             ) );\r\npFileName            =                 JsonToString( JsonGet( pJson, 'pFileName'          ) );\r\npMode                =                 JsonToString( JsonGet( pJson, 'pMode'              ) );\r\npPath                =                 JsonToString( JsonGet( pJson, 'pPath'              ) );\r\n# Numeric Parameters\r\npLogOutput           = StringToNumber( JsonToString( JsonGet( pJson, 'pLogOutput'         ) ) );\r\npStrictErrorHandling = StringToNumber( JsonToString( JsonGet( pJson, 'pStrictErrorHandling' ) ) );\r\n\r\n### Get the parameters that differ from the default\r\npDiffer = JsonDiff( pDefaultParameters, pJson );\r\nnSize = JsonSize( pDiffer );\r\nWHILE( nSize > 0 );\r\n  nSize = nSize - 1;\r\n  pDiffer = JsonReplace( pDiffer, '/'|NumberToString( nSize )|'/op', '\"add\"' );\r\nEND;\r\npJson = JsonPatch( '{}', pDiffer );\r\n\r\n### LogOutput parameters\r\nsMessages = JsonAdd( sMessages, '/Info/-', pJson );\r\nIF( pLogOutput = 1 );\r\n  LogOutput('INFO', JsonToString( sMessages, '/Info/0', 0, ' ' ) );\r\nENDIF;\r\n\r\n#EndRegion - Process Parameters\r\n#################################################################################################\r\n\r\n### check operating system\r\nIf( SubSt( GetProcessErrorFileDirectory, 2, 1 ) @= ':' );\r\n  sOS = 'Windows';\r\n  sOSDelim = '\\';\r\nElseIf( Scan( '/', GetProcessErrorFileDirectory ) > 0 );\r\n  sOS = 'Linux';\r\n  sOSDelim = '/';\r\nElse;\r\n  sOS = 'Windows';\r\n  sOSDelim = '\\';\r\nEndIf;\r\n\r\n## LogOutput parameters\r\nIF( pLogoutput = 1 );\r\n    LogOutput('INFO', Expand( cLogInfo ) );   \r\nENDIF;\r\n\r\nnErrors = 0;\r\n\r\n### PROCESS PROPERTIES\r\nDatasourceASCIIDelimiter = '';\r\nDatasourceASCIIQuoteCharacter = '';\r\n\r\n##Validate Mode\r\nIf(upper(pMode) @<> 'LOAD' & upper(pMode) @<> 'UNLOAD');\r\n    sMessage = Expand('Invalid Mode: %pMode%. Valid Modes are Load or Unload');\r\n    nErrors = nErrors + 1;\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nEndif;\r\n\r\n##Validate Cube\r\nIf( Trim(pCube) @= '' );\r\n    sMessage = Expand('No cube specified');\r\n    nErrors = nErrors + 1;\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nEndif;\r\n\r\n## Default filter delimiters\r\nIf( pDelim     @= '' );\r\n    pDelim     = '&';\r\nEndIf;\r\n\r\n# define backupdir\r\nIf(pPath @<> '');\r\n    If(Subst(pPath,long(pPath),1) @= sOSDelim );\r\n        sPath = pPath;\r\n    Else;\r\n        sPath = pPath | sOSDelim;\r\n    Endif;\r\nElse;\r\n  sPath = '.' | sOSDelim;\r\nEndif;\r\n\r\n## Default files names for storing rule and backups\r\nIF(pFileName@='' % Scan( pDelim, pCube )<>0);\r\n  sRuleFileName         = '%sCube%.txt';\r\n  sBackupFileName       = '%sCube%.rux.bkp_%cTimeStamp%.txt';\r\nElse;\r\n  sRuleFileName         = pFileName;\r\n  sBackupFileName       = '%pFileName%.bkp_%cTimeStamp%.txt';\r\nEndif;  \r\n  \r\n# Loop through list of Cubes\r\nsCubes = pCube;\r\nnCubeDelimIndex = 1;\r\n\r\nWhile( nCubeDelimIndex <> 0 );\r\n  nCubeDelimIndex = Scan( pDelim, sCubes );\r\n  If( nCubeDelimIndex = 0 );\r\n    sCube = sCubes;\r\n  Else;\r\n    sCube = Trim( SubSt( sCubes, 1, nCubeDelimIndex - 1 ) );\r\n    sCubes = Trim( Subst( sCubes, nCubeDelimIndex + Long(pDelim), Long( sCubes ) ) );\r\n  EndIf;\r\n\r\n  sMDX = Expand( '{TM1FILTERBYPATTERN(TM1SUBSETALL([}Cubes]), \"%sCube%\")}' );\r\n\r\n  sProc = '}bedrock.hier.sub.create.bymdx';\r\n  ExecuteProcess( sProc,\r\n    'pLogOutput', pLogOutput,\r\n    'pStrictErrorHandling', pStrictErrorHandling,\r\n    'pDim', cDimCubes,\r\n    'pHier', '',\r\n    'pSub', cTempSub,\r\n    'pMDXExpr', sMDX,\r\n    'pConvertToStatic', 1,\r\n    'pTemp', 1\r\n  );\r\n\r\n  nCube = 1;\r\n  nCubes = SubsetGetSize( cDimCubes, cTempSub );\r\n  While( nCube <= nCubes );\r\n    sCube = SubsetGetElementName( cDimCubes, cTempSub, nCube );\r\n    nCube = nCube + 1;\r\n    \r\n    cCubeRuleFileName = '.' | sOSDelim | sCube | '.txt';\r\n    cStoreDirFile = sPath | Expand(sRuleFileName);\r\n\r\n      ##Unloading the Rule###\r\n      If(Upper(pMode) @= 'UNLOAD');\r\n        ##Before unloading, backup the existing rule (saved as .bkp.txt in data directory or with the suffix parameter)\r\n        ##and drop current rule\r\n        sRule=CubeRuleGet( sCube );\r\n        ASCIIOutput(cStoreDirFile, sRule);\r\n        ## Check if the saved rule file exists\r\n        If( sRule@<>'' );\r\n          CubeRuleDestroy( sCube );\r\n        Else;\r\n          sMessage = Expand('Copy of rule file (%cCubeRuleFileName%) has failed, rule was not unloaded.');\r\n          nErrors = nErrors + 1;\r\n          LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n          If( pStrictErrorHandling = 1 ); \r\n              ProcessQuit; \r\n          Else;\r\n              ProcessBreak;\r\n          EndIf;\r\n        EndIf;\r\n\r\n      ##Loading the Rule###\r\n      ElseIf(Upper(pMode) @= 'LOAD');\r\n        ##Backup the existing rule (saved as .bkp.txt in given path or data directory) \r\n        ##and load the new rule file. New Rule file should available in the given path or in data directory\r\n        ## Check if the backup file exists\r\n        If( FileExists( cCubeRuleFileName ) <> 0 );\r\n          RuleLoadFromFile( sCube, cCubeRuleFileName);\r\n        Else;\r\n          nErrors = nErrors + 1;\r\n          sMessage = 'No Rule file found for cube: ' | sCube;\r\n          LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n          If( pStrictErrorHandling = 1 ); \r\n              ProcessQuit; \r\n          Else;\r\n              ProcessBreak;\r\n          EndIf;\r\n        EndIf;\r\n\r\n    Endif;\r\n  End;\r\nEnd;\r\n\r\n### end Prolog ###",
  "MetadataProcedure": "\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****",
  "DataProcedure": "\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****",
  "EpilogProcedure": "\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n\r\n################################################################################################# ####################\r\n##~~Join the bedrock TM1 community on GitHub https://github.com/cubewise-code/bedrock-5 Ver 5.0~~##\r\n################################################################################################# \r\n\r\n### Return code & final error message handling\r\nIf( nErrors > 0 );\r\n    sMessage = 'the process incurred at least 1 error. Please see above lines in this file for more details.';\r\n    nProcessReturnCode = 0;\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\r\n    If( pStrictErrorHandling = 1 ); \r\n        ProcessQuit; \r\n    EndIf;\r\nElse;\r\n    sProcessAction = Expand( 'Process:%cThisProcName% successfully %pMode% cube rule from cube %pCube% .' );\r\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\r\n    nProcessReturnCode = 1;\r\n    If( pLogoutput = 1 );\r\n        LogOutput('INFO', Expand( sProcessAction ) );   \r\n    EndIf;\r\nEndIf;\r\n\r\n### End Epilog ###",
  "HasSecurityAccess": true,
  "UIData": "",
  "DataSource": {
    "Type": "None"
  },
  "Parameters": [
    {
      "Name": "pCube",
      "Prompt": "REQUIRED: Cube name",
      "Value": "",
      "Type": "String"
    },
    {
      "Name": "pMode",
      "Prompt": "REQUIRED: Load/Unload the cube rule (=Load, the file name should be available in the data directory with the required file name Suffix)",
      "Value": "",
      "Type": "String"
    },
    {
      "Name": "pFileName",
      "Prompt": "OPTIONAL: File name (Default = pCube | '_Export.csv')",
      "Value": "",
      "Type": "String"
    },
    {
      "Name": "pDelim",
      "Prompt": "OPTIONAL: Delimiter for list parameters (Default = '&')",
      "Value": "&",
      "Type": "String"
    },
    {
      "Name": "pPath",
      "Prompt": "OPTIONAL: File directory (Default = GetProcessErrorFileDirectory)",
      "Value": "",
      "Type": "String"
    },
    {
      "Name": "pLogOutput",
      "Prompt": "OPTIONAL: Write parameters and action summary to server message log (Boolean. Default = 0)",
      "Value": 0,
      "Type": "Numeric"
    },
    {
      "Name": "pStrictErrorHandling",
      "Prompt": "OPTIONAL: On encountering any error, exit with major error status by ProcessQuit after writing to the server message log (Boolean. Default = 0)",
      "Value": 0,
      "Type": "Numeric"
    },
    {
      "Name": "pJson",
      "Prompt": "OPTIONAL: JSON Object with process parameter values. This will overwrite user passed parameters for all included parameters.",
      "Value": "{}",
      "Type": "String"
    }
  ],
  "Variables": [],
  "VariablesUIData": []
}