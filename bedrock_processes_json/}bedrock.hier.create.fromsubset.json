{
  "Name": "}bedrock.hier.create.fromsubset",
  "PrologProcedure": "#Region CallThisProcess\r\n# A snippet of code provided as an example how to call this process should the developer be working on a system without access to an editor with auto-complete.\r\nIf( 1 = 0 );\r\n    ExecuteProcess( '}bedrock.hier.create.fromsubset', 'pLogOutput', pLogOutput,\r\n      'pStrictErrorHandling', pStrictErrorHandling,\r\n    \t'pSrcDim', '', 'pSrcHier', '', 'pSubset', '',\r\n    \t'pTgtDim', '', 'pTgtHier', '',\r\n    \t'pAttr', 1, 'pUnwind', 0, 'pFlat', 0\r\n\t);\r\nEndIf;\r\n#EndRegion CallThisProcess\r\n\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n\r\n################################################################################################# \r\n##~~Join the bedrock TM1 community on GitHub https://github.com/cubewise-code/bedrock Ver 4~~##\r\n################################################################################################# \r\n\r\n#Region @DOC\r\n# Description:\r\n# This process will make a copy of an existing dimension subset, creating it as a new dimension hierarchy.\r\n\r\n# Use case: Intended for Development but could be used in production too.\r\n# 1. Create a new hierarchy for testing.\r\n# 2. Create a new hierarchy to reflect new business needs.\r\n\r\n# Note:\r\n# Valid source dimension name (pSrcDim) and source subset (pSubset) are mandatory, otherwise the process will abort.\r\n# If a source hierarchy name (pSrcHier) is specified, it needs to be valid, otherwise the process will abort.\r\n\r\n# Caution:\r\n# - Target hierarchy cannot be Leaves.\r\n# - If the target Hierarchy already exists, then it will be overwritten.\r\n#EndRegion @DOC\r\n\r\n### Global Variables\r\nStringGlobalVariable ('sProcessReturnCode');\r\nNumericGlobalVariable('nProcessReturnCode');\r\nnProcessReturnCode = 0;\r\n\r\n### Constants ###\r\ncThisProcName     = GetProcessName();\r\ncUserName         = TM1User();\r\ncTimeStamp        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\r\ncRandomInt        = NumberToString( INT( RAND( ) * 1000 ));\r\ncTempSub          = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\r\ncMsgErrorLevel    = 'ERROR';\r\ncMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\r\ncLogInfo          = 'Process:%cThisProcName% run with parameters pSrcDim:%pSrcDim%, pSrcHier:%pSrcHier%, pSubset:%pSubset%, pTgtDim:%pTgtDim%, pTgtHier:%pTgtHier%, pAttr:%pAttr%, pUnwind:%pUnwind%, pFlat:%pFlat%.';\r\ncHierAttr         = 'Bedrock.Descendant';\r\ncAttrVal          = 'Descendant';\r\n\r\n#################################################################################################\r\n#Region - Process Parameters\r\n\r\npJson = IF( JsonType( pJson ) @<> 'object', '{}', pJson );\r\nsMessages = '{\"Process\": \"'|GetProcessName()|'\", \"User\": \"'|TM1User()|'\", \"Info\": [\"Process: '''|GetProcessName()|''' run by User: '''|TM1User()|'''.\"], \"Error\": []}';\r\npDefaultParameters = '{\r\n  \"pSrcDim\":              null,\r\n  \"pSrcHier\":             \"\",\r\n  \"pSubset\":              null,\r\n  \"pTgtDim\":              \"\",\r\n  \"pTgtHier\":             \"\",\r\n  \"pAttr\":                1,\r\n  \"pFlat\":                0,\r\n  \"pLogOutput\":           0,\r\n  \"pStrictErrorHandling\": 0,\r\n  \"pUnwind\":              0\r\n}';\r\n\r\npPassedParameters = '{\r\n  \"pSrcDim\":              '|StringToJson  ( pSrcDim              )|',\r\n  \"pSrcHier\":             '|StringToJson  ( pSrcHier             )|',\r\n  \"pSubset\":              '|StringToJson  ( pSubset              )|',\r\n  \"pTgtDim\":              '|StringToJson  ( pTgtDim              )|',\r\n  \"pTgtHier\":             '|StringToJson  ( pTgtHier             )|',\r\n  \"pAttr\":                '|NumberToString( pAttr                )|',\r\n  \"pFlat\":                '|NumberToString( pFlat                )|',\r\n  \"pLogOutput\":           '|NumberToString( pLogOutput           )|',\r\n  \"pStrictErrorHandling\": '|NumberToString( pStrictErrorHandling )|',\r\n  \"pUnwind\":              '|NumberToString( pUnwind              )|'\r\n}';\r\n\r\npJson = JsonMergePatch( pPassedParameters, pJson );\r\n# String Parameters\r\npSrcDim              =                 JsonToString( JsonGet( pJson, 'pSrcDim'            ) );\r\npSrcHier             =                 JsonToString( JsonGet( pJson, 'pSrcHier'           ) );\r\npSubset              =                 JsonToString( JsonGet( pJson, 'pSubset'            ) );\r\npTgtDim              =                 JsonToString( JsonGet( pJson, 'pTgtDim'            ) );\r\npTgtHier             =                 JsonToString( JsonGet( pJson, 'pTgtHier'           ) );\r\n# Numeric Parameters\r\npAttr                = StringToNumber( JsonToString( JsonGet( pJson, 'pAttr'              ) ) );\r\npFlat                = StringToNumber( JsonToString( JsonGet( pJson, 'pFlat'              ) ) );\r\npLogOutput           = StringToNumber( JsonToString( JsonGet( pJson, 'pLogOutput'         ) ) );\r\npStrictErrorHandling = StringToNumber( JsonToString( JsonGet( pJson, 'pStrictErrorHandling' ) ) );\r\npUnwind              = StringToNumber( JsonToString( JsonGet( pJson, 'pUnwind'            ) ) );\r\n\r\n### Get the parameters that differ from the default\r\npDiffer = JsonDiff( pDefaultParameters, pJson );\r\nnSize = JsonSize( pDiffer );\r\nWHILE( nSize > 0 );\r\n  nSize = nSize - 1;\r\n  pDiffer = JsonReplace( pDiffer, '/'|NumberToString( nSize )|'/op', '\"add\"' );\r\nEND;\r\npJson = JsonPatch( '{}', pDiffer );\r\n\r\n### LogOutput parameters\r\nsMessages = JsonAdd( sMessages, '/Info/-', pJson );\r\nIF( pLogOutput = 1 );\r\n  LogOutput('INFO', JsonToString( sMessages, '/Info/0', 0, ' ' ) );\r\nENDIF;\r\n\r\n#EndRegion - Process Parameters\r\n#################################################################################################\r\n\r\n## LogOutput parameters\r\nIF ( pLogoutput = 1 );\r\n  LogOutput('INFO', Expand( cLogInfo ) );   \r\nENDIF;\r\n\r\n### Validate Parameters ###\r\nnErrors = 0;\r\nIf( Scan( ':', pSrcDim ) > 0 & pSrcHier @= '' );\r\n    # A hierarchy has been passed as dimension. Handle the input error by splitting dim:hier into dimension & hierarchy\r\n    pSrcHier       = SubSt( pSrcDim, Scan( ':', pSrcDim ) + 1, Long( pSrcDim ) );\r\n    pSrcDim        = SubSt( pSrcDim, 1, Scan( ':', pSrcDim ) - 1 );\r\nEndIf;\r\n\r\nIf( Scan( ':', pTgtDim ) > 0 & pTgtHier @= '' );\r\n    # A hierarchy has been passed as dimension. Handle the input error by splitting dim:hier into dimension & hierarchy\r\n    pTgtHier       = SubSt( pTgtDim, Scan( ':', pTgtDim ) + 1, Long( pTgtDim ) );\r\n    pTgtDim        = SubSt( pTgtDim, 1, Scan( ':', pTgtDim ) - 1 );\r\nEndIf;\r\n\r\n# Validate source dimension\r\nIF( Trim( pSrcDim ) @= '' );\r\n    nErrors = 1;\r\n    sMessage = 'No source dimension specified.';\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nEndIf;\r\n\r\nIF( DimensionExists( pSrcDim ) = 0 );\r\n    nErrors = 1;\r\n    sMessage = 'Invalid source dimension: ' | pSrcDim;\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nEndIf;\r\n\r\n### Check for errors before continuing\r\nIf( nErrors <> 0 );\r\n   If( pStrictErrorHandling = 1 ); \r\n      ProcessQuit; \r\n  Else;\r\n      ProcessBreak;\r\n  EndIf;\r\nEndIf;\r\n\r\n# Validate source Hierarchy\r\nIF(pSrcHier @= '');\r\n    pSrcHier = pSrcDim;\r\nElseIf(HierarchyExists(pSrcDim, pSrcHier) = 0);\r\n    nErrors = 1;\r\n    sMessage = 'Invalid source hierarchy: ' | pSrcHier;\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nEndif;\r\n\r\n## Validate Source Subset\r\nIF(HierarchySubsetExists( pSrcDim, pSrcHier, pSubset) = 0 );\r\n    sMessage = 'No valid source subset: ' | pSubset;\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\nELSE;\r\n    cSubset = pSubset;\r\nENDIF;\r\n\r\n### Check for errors before continuing\r\nIf( nErrors <> 0 );\r\n  If( pStrictErrorHandling = 1 ); \r\n      ProcessQuit; \r\n  Else;\r\n      ProcessBreak;\r\n  EndIf;\r\nEndIf;\r\n\r\n## Validate target Dimension\r\nIf(pTgtDim @= '');\r\n    pTgtDim = pSrcDim;\r\nEndif;\r\n\r\nIF( DimensionExists( pTgtDim ) = 0 );\r\n   DimensionCreate(pTgtDim);\r\nEndIf;\r\n\r\n### Create target dimension Hierarchy ###\r\nIF(pTgtHier @= '');\r\n    pTgtHier = pTgtDim;\r\nEndIf;\r\n\r\n\r\nIf( HierarchyExists(pTgtDim, pTgtHier) = 0 );\r\n    HierarchyCreate( pTgtDim, pTgtHier );\r\nElse;\r\n    IF(pUnwind = 1 );\r\n        ExecuteProcess( '}bedrock.hier.unwind', 'pLogOutput', 0,\r\n            'pStrictErrorHandling', pStrictErrorHandling,\r\n            'pDim', pTgtDim, 'pHier', pTgtHier, 'pConsol', '*',\r\n            'pRecursive', 1\r\n        );\r\n    ELSEIF(\r\n        pUnwind = 2 );\r\n        #Do nothing\r\n    ELSE;\r\n        HierarchyDeleteAllElements( pTgtDim, pTgtHier );\r\n    EndIf;\r\nEndIf;\r\n\r\n### Assign Data Source ###\r\nDatasourceNameForServer = pSrcDim|':'|pSrcHier;\r\nDatasourceNameForClient = pSrcDim|':'|pSrcHier;\r\nDataSourceType = 'SUBSET';\r\nDatasourceDimensionSubset = cSubset;\r\n\r\n### Set Descendent attribute value\r\nAttrDelete( pSrcDim, cHierAttr );\r\nAttrInsert( pSrcDim, '', cHierAttr, 'S' );\r\n\r\nnIndex = 1;\r\nnLimit = HierarchySubsetGetSize( pSrcDim, pSrcHier, pSubset );\r\nWHILE( nIndex <= nLimit);\r\n    sElName = HierarchySubsetGetElementName( pSrcDim, pSrcHier, pSubset, nIndex );\r\n    ElementAttrPuts( cAttrVal, pSrcDim, pSrcHier, sElName, cHierAttr );\r\n    sElType = ElementType( pSrcDim, pSrcHier, sElName );\r\n    HierarchyElementInsert(pTgtDim, pTgtHier, '',sElName, sELType);\r\n    nIndex = nIndex + 1;\r\nEND;\r\n\r\n### Replicate Attributes ###\r\n# Note: DType on Attr dim returns \"AS\", \"AN\" or \"AA\" need to strip off leading \"A\"\r\n\r\nsTgtAttrDim = '}ElementAttributes_' | pTgtDim;\r\nsSrcAttrDim = '}ElementAttributes_' | pSrcDim;\r\nsLastAttr = '';\r\nIf( pAttr = 1 & DimensionExists( sSrcAttrDim ) = 1 );\r\n    nNumAttrs = DimSiz( sSrcAttrDim );\r\n    nCount = 1;\r\n    While( nCount <= nNumAttrs );\r\n        sAttrName = DimNm( sSrcAttrDim, nCount );\r\n        sAttrType = SubSt(DType( sSrcAttrDim, sAttrName ), 2, 1 );\r\n        AttrInsert( pTgtDim, sLastAttr, sAttrName, sAttrType );\r\n        sLastAttr = sAttrName;\r\n        nCount = nCount + 1;\r\n    End;\r\nEndIf;\r\n \r\n### End Prolog ###",
  "MetadataProcedure": "\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n\r\n### Check for errors in prolog ###\r\nIf( nErrors <> 0 );\r\n  If( pStrictErrorHandling = 1 ); \r\n      ProcessQuit; \r\n  Else;\r\n      ProcessBreak;\r\n  EndIf;\r\nEndIf;\r\n\r\nIf (pFlat = 1);\r\n    ##Creating the Flat hierarchy subset in the target dimension\r\n    sElType = ElementType(pSrcDim, pSrcHier, vElement);\r\n    ## Add the element to the target dimension.\r\n    ## 'C' elements can't be inserted as 'N' elements in the same dimension\r\n    IF(pTgtdim @= pSrcDim);\r\n        IF(sElType @<> 'C' );\r\n            HierarchyElementInsert( pTgtDim, pTgtHier, '', vElement, sElType );\r\n        Else;\r\n            If( pLogOutput = 1 );\r\n                sMessage = 'Name conflict! Cannot create leaf element %vElement% in dimension %pTgtDim% as C element with same name already exists.';\r\n                LogOutput( 'WARN', Expand( cMsgErrorContent ) );\r\n            EndIf;\r\n        EndIf;\r\n    Else;\r\n        IF(sElType @= 'C' );\r\n            HierarchyElementInsert( pTgtDim, pTgtHier, '', vElement, 'N' );\r\n        Else;\r\n            HierarchyElementInsert( pTgtDim, pTgtHier, '', vElement, sElType );\r\n        EndIf;\r\n    EndIf;\r\nElse;\r\n    nIndex = 1;\r\n    nLimit = ElementComponentCount( pSrcDim, pSrcHier, vElement );\r\n    WHILE( nIndex <= nLimit );\r\n        sElName = ElementComponent( pSrcDim, pSrcHier, vElement, nIndex );\r\n        sDecendant = ElementAttrS(pSrcDim, pSrcHier, sElName, cHierAttr);\r\n        IF(\r\n            sDecendant @= cAttrVal);\r\n            nElWeight = ElementWeight( pSrcDim, pSrcHier, vElement, sElName );\r\n            HierarchyElementComponentAdd( pTgtDim, pTgtHier, vElement, sElName, nElWeight );\r\n        ENDIF;\r\n        nIndex = nIndex + 1;\r\n    END;\r\nEndif;\r\n\r\n### End MetaData ###",
  "DataProcedure": "\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n\r\n\r\n### Check for errors in prolog ###\r\nIf( nErrors <> 0 );\r\n  If( pStrictErrorHandling = 1 ); \r\n      ProcessQuit; \r\n  Else;\r\n      ProcessBreak;\r\n  EndIf;\r\nEndIf;\r\n\r\n\r\n### Replicate Attributes ###\r\n\r\n# Note: DTYPE on Attr dim returns \"AS\", \"AN\" or \"AA\" need to strip off leading \"A\"\r\n\r\nIf( pAttr = 1 );\r\n\r\n    nCount = 1;\r\n    While( nCount <= nNumAttrs );\r\n        sAttrName = DimNm( sSrcAttrDim, nCount );\r\n        sAttrType = SubSt( DTYPE( sSrcAttrDim, sAttrName ), 2, 1 );\r\n        If( sAttrType @= 'S' % sAttrType @= 'A' );\r\n            sAttrVal = ElementAttrS(pSrcDim, pSrcHier, vElement, sAttrName);\r\n            If( sAttrVal @<> '' );\r\n                If( pStrictErrorHandling = 0 & CellIsUpdateable(sTgtAttrDim, pTgtHier:vElement, sAttrName) = 0 );\r\n                    #skip\r\n                ElseIf( sAttrType @= 'A' );\r\n                    ElementAttrPutS( sAttrVal, pTgtDim, pTgtHier, vElement, sAttrName, 1 );\r\n                Else;\r\n                    ElementAttrPutS( sAttrVal, pTgtDim, pTgtHier, vElement, sAttrName );\r\n                EndIf;\r\n            EndIf;\r\n        Else;\r\n            nAttrVal = ElementAttrN(pSrcDim, pSrcHier, vElement, sAttrName);\r\n            If( nAttrVal <> 0 );\r\n                If( pStrictErrorHandling = 0 & CellIsUpdateable(sTgtAttrDim, pTgtHier:vElement, sAttrName) = 0 );\r\n                    #skip\r\n                Else;\r\n                    ElementAttrPutN( nAttrVal, pTgtDim, pTgtHier, vElement, sAttrName );\r\n                EndIf;\r\n            EndIf;\r\n        EndIf;\r\n        nCount = nCount + 1;\r\n    End;\r\n\r\n  EndIf;\r\n\r\n### End Data ###",
  "EpilogProcedure": "\r\n#****Begin: Generated Statements***\r\n#****End: Generated Statements****\r\n\r\n### Set Target dimension sort order ###\r\n\r\nIf(pSrcDim @= pSrcHier);\r\n    sSourceElement = pSrcDim;\r\nElse;\r\n    sSourceElement = pSrcDim|':'|pSrcHier;\r\nEndif;\r\nIf(pTgtDim @= pTgtHier);\r\n    sTargetElement = pTgtDim;\r\nElse;\r\n    sTargetElement = pTgtDim|':'|pTgtHier;\r\nEndif;\r\n\r\n# Placeholder for copying dimension order and captions from source to target as expecting a TI function to be made available to be able to read & modify these properties\r\n\r\n### Set Descendent attribute value\r\nAttrDelete( pSrcDim, cHierAttr );\r\nIf( pAttr = 1 );\r\n    AttrDelete( pTgtDim, cHierAttr );\r\nENDIF;\r\n\r\n### Return code & final error message handling\r\nIf( nErrors > 0 );\r\n    sMessage = 'the process incurred at least 1 error. Please see above lines in this file for more details.';\r\n    nProcessReturnCode = 0;\r\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\r\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\r\n    If( pStrictErrorHandling = 1 ); \r\n        ProcessQuit; \r\n    EndIf;\r\nElse;\r\n    sProcessAction = Expand( 'Process:%cThisProcName% successfully cloned dimension:hierarchy %pSrcDim%:%pSrcHier% to %pTgtDim%:%pTgtHier% based on the %pSubset% subset.' );\r\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\r\n    nProcessReturnCode = 1;\r\n    If( pLogoutput = 1 );\r\n        LogOutput('INFO', Expand( sProcessAction ) );   \r\n    EndIf;\r\nEndIf;\r\n\r\n### End Epilog ###",
  "HasSecurityAccess": true,
  "UIData": "",
  "DataSource": {
    "Type": "TM1DimensionSubset",
    "dataSourceNameForClient": "}Cubes",
    "dataSourceNameForServer": "}Cubes",
    "subset": "All"
  },
  "Parameters": [
    {
      "Name": "pSrcDim",
      "Prompt": "REQUIRED: Source dimension name",
      "Value": "",
      "Type": "String"
    },
    {
      "Name": "pSrcHier",
      "Prompt": "OPTIONAL: Source hierarchy name (Default = pSrcDim)",
      "Value": "",
      "Type": "String"
    },
    {
      "Name": "pSubset",
      "Prompt": "REQUIRED: Subset name",
      "Value": "",
      "Type": "String"
    },
    {
      "Name": "pTgtDim",
      "Prompt": "OPTIONAL: Target dimension name (Default = pSrcDim)",
      "Value": "",
      "Type": "String"
    },
    {
      "Name": "pTgtHier",
      "Prompt": "OPTIONAL: Target hierarchy name (Default = pTgtDim)",
      "Value": "",
      "Type": "String"
    },
    {
      "Name": "pAttr",
      "Prompt": "OPTIONAL: Include attributes (Boolean. Default = 1)",
      "Value": 1,
      "Type": "Numeric"
    },
    {
      "Name": "pUnwind",
      "Prompt": "OPTIONAL: Unwind target hierarchy before process (0 = Delete all elements, 1 = Unwind existing elements, 2 = Do not change existing elements. Default = 0)",
      "Value": 0,
      "Type": "Numeric"
    },
    {
      "Name": "pFlat",
      "Prompt": "OPTIONAL: Create the hierarchy flat (Boolean. Default = 0)",
      "Value": 0,
      "Type": "Numeric"
    },
    {
      "Name": "pLogOutput",
      "Prompt": "OPTIONAL: Write parameters and action summary to server message log (Boolean. Default = 0)",
      "Value": 0,
      "Type": "Numeric"
    },
    {
      "Name": "pStrictErrorHandling",
      "Prompt": "OPTIONAL: On encountering any error, exit with major error status by ProcessQuit after writing to the server message log (Boolean. Default = 0)",
      "Value": 0,
      "Type": "Numeric"
    },
    {
      "Name": "pJson",
      "Prompt": "OPTIONAL: JSON Object with process parameter values. This will overwrite user passed parameters for all included parameters.",
      "Value": "{}",
      "Type": "String"
    }
  ],
  "Variables": [
    {
      "Name": "vElement",
      "Type": "String",
      "Position": 1,
      "StartByte": 0,
      "EndByte": 0
    }
  ],
  "VariablesUIData": [
    "VarType=32\fColType=827\f"
  ]
}